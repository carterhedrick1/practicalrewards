<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TXPB5KSTNP"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-TXPB5KSTNP');
    </script>
    <!-- Microsoft Clarity -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "t8qvj4h0gj");
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="theme-color" content="#0f2027">
    <!-- Critical header styles - prevents loading flash -->
    <link rel="stylesheet" href="/css/critical-header.css">
    <title>Practical Picks - Practical Rewards</title>
    <meta name="description" content="Get personalized credit card recommendations based on your spending habits and personality. Answer a few questions to find cards that actually fit your lifestyle.">
    <link rel="canonical" href="https://practicalrewards.com/practical-picks.html">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/favicons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/favicons/apple-touch-icon.png">
    <link rel="manifest" href="/favicons/site.webmanifest">


    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; overflow-x: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6; color: #292524; background: #fafaf9; overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        .coach-container { max-width: 1400px; margin: 0 auto; padding: 20px 2rem 0 2rem; }


        /* Layout */
        .coach-layout { display: grid; grid-template-columns: 340px 1fr; gap: 2rem; align-items: start; }
        @media (max-width: 1024px) { 
            .coach-layout { 
                grid-template-columns: 1fr; 
                gap: 0;
            }
            .results-bar {
                margin-bottom: 1.5rem;
                padding: .5rem 1rem;
            }
            .cards-grid {
                gap: 1rem;
                margin: 0;
            }
        }

        /* Wizard */
        .wizard { position: sticky; top: 100px; background: white; border: 1px solid #e5e7eb; border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06); padding: 0.75rem; transition: all 0.3s ease; }
        
        .wizard.completion {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: 1px solid #059669;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.25);
        }
        .wizard-header { margin-bottom: .5rem; }
        .wizard-title { font-size: 1.1rem; font-weight: 700; color: #047857; }
        .wizard-title.question { font-size: 1.3rem; font-weight: 600; color: #047857; line-height: 1.3; }
        .progress { height: 6px; background: #e5e7eb; border-radius: 9999px; overflow: hidden; margin: .5rem 0; }
        .wizard-actions { display: flex; gap: .5rem; align-items: center; justify-content: center; margin-top: .75rem; }
        .progress > span { display: block; height: 100%; width: 0; background: linear-gradient(135deg,#059669,#10b981); transition: width .3s ease; }
        .step { padding: .5rem; border: 1px solid #e5e7eb; border-radius: 10px; margin-bottom: .5rem; }
        .step h3 { font-size: 1rem; color: #1e293b; margin-bottom: .5rem; }
        #steps-container { margin-bottom: .5rem; }
        .options { display: grid; grid-template-columns: 1fr; gap: .5rem; }
        .option { 
            border: 2px solid #e2e8f0; 
            border-radius: 10px; 
            padding: .75rem; 
            background: white; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            gap: .5rem; 
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
            min-height: 44px; /* Minimum touch target size for mobile */
            position: relative;
        }
        
        /* Improve scrolling over options on mobile */
        @media (max-width: 1024px) {
            .option {
                touch-action: pan-y; /* Allow vertical scrolling */
            }
        }
        .option input { 
            margin: 0; 
            pointer-events: none;
        }
        .option.active { border-color: #059669; background: #f0fdf4; }
        .option:active { 
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }
        
        /* Prevent stuck active states */
        .option:focus {
            outline: none;
        }
        
        .option:not(.active):not(:hover) {
            border-color: #e2e8f0;
            background: white;
        }
        
        /* Only show hover effects on devices that support hover (not mobile) */
        @media (hover: hover) and (pointer: fine) {
            .option:hover { border-color: #10b981; background: #f9fafb; }
        }
        .btn { padding: .6rem 1rem; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; }
        .btn-primary { background: #059669; color: white; }
        .btn-secondary { background: white; color: #059669; border: 1px solid #059669; }

        /* Context help box in wizard */
        .help-box { 
            margin-top: .5rem; 
            background: #f8fafc; 
            border: 1px solid #e5e7eb; 
            border-left: 3px solid #059669; 
            border-radius: 8px; 
            padding: 1rem; 
            position: relative;
            display: none; /* Hide by default, show when needed */
        }
        .help-title { 
            font-weight: 700; 
            color: #059669; 
            font-size: 1rem; 
            margin-bottom: 0.5rem; 
            text-transform: uppercase; 
            letter-spacing: .5px; 
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        .help-title .expand-icon {
            transition: transform 0.3s ease;
            font-size: 0.9rem;
            color: #059669;
        }
        .help-title.expanded .expand-icon {
            transform: rotate(180deg);
        }
        .help-text { 
            color: #475569; 
            font-size: 0.95rem; 
            line-height: 1.6; 
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, margin-top 0.3s ease;
            margin-top: 0;
        }
        .help-text.expanded {
            max-height: 500px;
            margin-top: 0.5rem;
        }
        
        /* Collapsible states - desktop version with fade and arrow like mobile */
        .help-box.collapsible .help-text {
            max-height: 112px;
            overflow: hidden;
            position: relative;
            transition: max-height 0.3s ease, margin-top 0.3s ease;
            margin-top: 0.5rem;
        }
        
        .help-box.collapsible.expanded .help-text {
            max-height: 500px;
            margin-top: 0.5rem;
        }
        
        .help-box.collapsible.collapsed .help-text {
            max-height: 112px;
            overflow: hidden;
            position: relative;
        }
        
        /* Fade effect and arrow for collapsed state */
        .help-box.collapsed .help-text::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23059669' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") center 85% / 20px 20px no-repeat,
                        linear-gradient(to bottom, rgba(248, 250, 252, 0.15) 0%, rgba(248, 250, 252, 0.35) 30%, rgba(248, 250, 252, 0.65) 65%, #f8fafc 100%);
            pointer-events: none;
            z-index: 1;
        }
        
        .help-box.collapsed .help-title .expand-icon {
            display: none;
        }
        
        /* Explicitly set expanded state to override collapsed max-height */
        .help-box.expanded .help-text {
            max-height: none !important;
            overflow: visible !important;
        }
        
        .help-box.expanded .help-text::after {
            display: none;
        }
        
        .help-box.expanded .help-title .expand-icon {
            display: none;
        }

        /* Content side */
        .results-bar { display: flex; align-items: center; justify-content: space-between; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 12px; padding: .75rem 1rem; margin-bottom: 1rem; }
        .tabs { display: flex; gap: .5rem; }
        .tab { padding: .5rem .9rem; border-radius: 9999px; border: 1px solid #e5e7eb; background: white; cursor: pointer; }
        .tab.active { background: #059669; color: white; border-color: #059669; }

        /* Cards Grid & Card styles copied from cards.html for perfect parity */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin: 0;
            /* Performance optimizations for smooth animations */
            contain: layout style paint;
            transform: translateZ(0); /* Force hardware acceleration */
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Ensure cards are visible in completion state */
        .cards-grid .completion-card {
            opacity: 1 !important;
            transform: scale(1) !important;
            visibility: visible !important;
        }

        /* Override grid layout when showing intro text */
        .cards-grid.showing-intro {
            display: block;
            grid-template-columns: none;
        }

        .card-item {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            border: 1px solid #e5e7eb;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            color: inherit;
            display: block;
            opacity: 1;
            transform: scale(1);
            text-align: center;
        }

        .card-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        /* Disable default card hover animations - use only image scaling and green border */
        .card-item:hover::before { display: none; }
        .card-item:hover { 
            transform: none; 
            box-shadow: 0 2px 12px rgba(0,0,0,0.08); 
            border-color: #059669; 
        }
        
        /* Enable subtle image scaling for all cards */
        .card-item .card-image {
            transition: transform 0.3s ease;
        }
        
        .card-item:hover .card-image {
            transform: scale(1.05);
        }
        
        /* Ensure all non-completion cards use consistent styling */
        .wizard:not(.completion) ~ section .card-item,
        .cards-grid .card-item:not(.completion-card) {
            box-shadow: 0 2px 12px rgba(0,0,0,0.08) !important;
            border: 1px solid #e5e7eb !important;
        }
        
        .wizard:not(.completion) ~ section .card-item:hover,
        .cards-grid .card-item:not(.completion-card):hover {
            transform: none !important;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08) !important;
            border-color: #059669 !important;
            border-width: 1px !important;
        }
        
        /* Disable hover effects on mobile to prevent confusion */
        @media (max-width: 768px) {
            .card-item:hover { 
                transform: none !important; 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08) !important; 
                border-color: #e5e7eb !important; 
            }
            .card-item:hover .card-image { 
                transform: none !important; 
            }
        }

        .card-image {
            width: 100%;
            max-width: 200px;
            height: 140px;
            object-fit: contain;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            box-shadow: none;
            border: none;
            transition: transform 0.3s ease;
        }

        .card-item:hover .card-image { transform: scale(1.02); }

        .card-image-fallback {
            width: 100%;
            max-width: 240px;
            height: 140px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            box-shadow: none;
            border: none;
        }

        .card-header { display: flex; justify-content: center; align-items: center; margin-bottom: 0.75rem; height: 40px; flex-shrink: 0; }
        .card-title { font-size: 1.1rem; font-weight: 600; color: #1e293b; margin: 0; line-height: 1.3; text-align: center; }
        .card-meta-row { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; flex-wrap: wrap; justify-content: center; height: 32px; align-items: center; flex-shrink: 0; }
        .meta-chip { background: #f1f5f9; color: #64748b; padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 500; white-space: nowrap; }
        .card-earning-rates { color: #374151; margin-bottom: 0.5rem; font-size: 0.8rem; line-height: 1.3; text-align: center; }
        .card-perks { color: #6b7280; font-size: 0.75rem; line-height: 1.3; margin-bottom: 0.5rem; text-align: center; }
        .card-advice { background: #f8fafc; border-left: 3px solid #059669; padding: 1rem; margin-top: 0.75rem; border-radius: 0 8px 8px 0; text-align: center; height: 100px; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .card-advice-label { font-weight: 600; color: #059669; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem; }
        .card-advice-text { color: #475569; font-size: 0.75rem; line-height: 1.4; font-style: italic; text-align: center; max-width: 100%; }

        /* Card transition animations - super smooth and simple */
        .card-item {
            transition: all 0.25s ease-out;
            will-change: opacity, transform;
        }
        
        .card-item.fade-out { 
            opacity: 0; 
            transform: translateY(-5px); 
            pointer-events: none;
        }
        
        .card-item.fade-in { 
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s ease-out;
        }
        

        /* Recommendation list styling (matching card pages) */
        .recommendation-list li strong {
            color: #1e293b !important; /* Black for bold benefit names */
            font-weight: 600 !important;
        }

        .recommendation-list li {
            color: #64748b !important; /* Lighter grey for descriptions */
            font-size: 0.9rem !important; /* Smaller font size */
            line-height: 1.5 !important;
        }

        /* Ensure the text after the dash is styled correctly */
        .help-box .recommendation-list li {
            color: #64748b !important;
            font-size: 0.9rem !important;
        }

        .help-box .recommendation-list li strong {
            color: #1e293b !important;
            font-weight: 600 !important;
        }

        /* Style quiz options with vertical layout */
        .option label {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            width: 100%;
        }

        .option input[type="radio"],
        .option input[type="checkbox"] {
            display: none !important; /* Hide radio buttons completely */
        }

        /* Create a container for the text content */
        .option .text-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            width: 100%;
        }

        /* Style the strong text at top */
        .option .text-content strong {
            color: #1e293b !important;
            font-weight: 600 !important;
            font-size: 0.85rem !important;
            line-height: 1.2 !important;
        }

        /* Style the descriptive text underneath */
        .option .text-content .description {
            color: #64748b !important;
            font-size: 0.9rem !important;
            line-height: 1.4 !important;
        }

        /* Skip options look identical to regular options, just with dashed border */
        .option:has(.skip-option) {
            border: 2px dashed #e2e8f0 !important;
            border-radius: 10px;
            padding: .75rem;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: .5rem;
            transition: all 0.3s ease;
            min-height: 44px;
            max-height: 44px; /* Prevent height expansion */
            color: #292524; /* Same as body text color */
        }

        .option:has(.skip-option).active {
            border-color: #059669 !important;
            background: #f0fdf4 !important;
        }

        /* Make skip option content look like regular option text */
        .option .text-content.skip-option {
            background: none;
            border: none;
            border-radius: 0;
            text-align: left;
            display: block;
            width: auto;
            height: auto;
            padding: 0;
            margin: 0;
            color: #292524; /* Same as body text color */
        }

        .option .text-content.skip-option strong {
            color: #292524 !important; /* Same as body text color */
            font-size: inherit;
            font-weight: inherit;
        }

        /* Space-efficient grid layout for category options */
        .options.grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            grid-auto-rows: 1fr;
        }

        .options.grid-layout .option {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.75rem 0.5rem;
            min-height: 48px;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 8px;
        }

        .options.grid-layout .option label {
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 0;
            width: 100%;
            height: 100%;
        }

        .options.grid-layout .option.active {
            border-color: #059669;
            background: #f0fdf4;
            transform: scale(1.02);
        }

        /* Only show grid hover effects on devices that support hover (not mobile) */
        @media (hover: hover) and (pointer: fine) {
            .options.grid-layout .option:hover {
                border-color: #10b981;
                background: #f9fafb;
            }
        }

        /* Responsive adjustments for grid */
        @media (max-width: 768px) {
            .options.grid-layout {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.4rem;
            }
        }

        @media (max-width: 480px) {
            .options.grid-layout {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.4rem;
            }
            
            .options.grid-layout .option {
                padding: 0.6rem 0.4rem;
                font-size: 0.85rem;
                min-height: 42px;
            }
        }


        /* Step tip styling */
        .step-tip {
            font-style: italic;
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        /* Desktop tweaks */
        @media (min-width: 769px) {
            /* Hide results bar and filter bar on desktop */
            .results-bar {
                display: none !important;
            }

            #active-filters-line {
                display: none !important;
            }

            /* Desktop card count indicator */
            .desktop-card-count {
                /* visibility controlled by JS; default hidden */
                display: none;
                background: #059669;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                margin: 0 0 1rem 0;
                padding: 0.5rem 0.75rem;
                text-align: center;
                border: none;
            }

            .desktop-card-count-number {
                font-size: 1.25rem;
                font-weight: 700;
                color: white;
                line-height: 1;
                margin-bottom: 0.15rem;
            }

            .desktop-card-count-label {
                font-size: 0.8rem;
                color: white;
                font-weight: 600;
                margin-bottom: 0;
                opacity: 0.9;
            }
        }

        /* Hide desktop indicator on mobile */
        @media (max-width: 768px) {
            .desktop-card-count {
                display: none !important;
            }
        }

        /* Mobile tweaks */
        @media (max-width: 768px) {

            .coach-container { padding: 20px 1rem 0 1rem; }

            /* Additional mobile improvements for wizard */
            .wizard {
                position: static;
                margin-bottom: 1rem;
                margin-top: 0;
            }
            
            .wizard-header {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                gap: 0.5rem;
            }
            
            .wizard-title {
                flex: 1;
                min-width: 0;
            }
            
            .wizard-actions {
                flex-shrink: 0;
                gap: 0.5rem;
            }
            
            .wizard-actions .btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
                min-width: 60px;
            }
            
            /* Mobile scroll indicator - pinned to bottom */
            .mobile-scroll-indicator {
                background: #059669;
                border-radius: 6px 6px 0 0;
                box-shadow: 0 -2px 8px rgba(0,0,0,0.15);
                margin: 0;
                margin-left: 0 !important;
                margin-right: 0 !important;
                padding: 0.75rem 0;
                padding-left: 0 !important;
                padding-right: 0 !important;
                text-align: center;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100vw !important;
                max-width: none !important;
                z-index: 1000;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.5rem;
                min-height: 60px;
                box-sizing: border-box;
            }
            
            /* Hide results bar and filter bar on mobile */
            .results-bar {
                display: none !important;
            }
            
            #active-filters-line {
                display: none !important;
            }
            
            /* Add bottom padding to prevent content from being hidden behind fixed indicator */
            .cards-grid {
                padding-bottom: 100px !important;
            }
            
            /* Also add padding to main content sections */
            main, section {
                padding-bottom: 100px !important;
            }
            
            .mobile-scroll-count {
                font-size: 1rem;
                font-weight: 700;
                color: white;
                line-height: 1;
                margin: 0;
            }
            
            .mobile-scroll-label {
                font-size: 0.65rem;
                color: white;
                font-weight: 600;
                margin: 0;
                white-space: nowrap;
                opacity: 0.9;
            }
            
            
            /* Collapsible help box for mobile */
            .help-box {
                margin-top: 1rem;
                padding: 1rem;
                background: #f8fafc;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                border-left: 3px solid #059669;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow-x: hidden;
                overflow-y: visible;
                display: none; /* Hide by default on mobile too */
            }
            
            .help-title {
                font-size: 1rem;
                margin-bottom: 0.5rem;
            }
            
            .help-text {
                color: #475569;
                font-size: 0.95rem;
                line-height: 1.6;
                max-height: none;
                overflow-x: hidden;
                overflow-y: visible;
                transition: all 0.3s ease;
                word-wrap: break-word;
                overflow-wrap: break-word;
                hyphens: auto;
                box-sizing: border-box;
                width: 100%;
                max-width: 100%;
            }
            
            /* Collapsible behavior for mobile - expanded by default */
            .help-box.collapsible .help-text {
                max-height: none;
                overflow-x: hidden;
                overflow-y: visible;
                position: relative;
            }
            
            .help-box.collapsible:not(.collapsed) .help-text::after {
                display: none;
            }
            
            .help-box.collapsible .help-title::after {
                content: '▼';
                font-size: 0.8rem;
                transition: transform 0.3s ease;
                margin-left: 0.5rem;
            }
            
            .help-box.expanded .help-title::after {
                /* Hide the arrow entirely when expanded */
                display: none;
            }
            
            /* Collapsed state when content is too long */
            .help-box.collapsed .help-text {
                max-height: 50px;
                overflow: hidden;
                position: relative;
            }

            .help-box.collapsed .help-text::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 40px;
                /* Smaller chevron and fade to take less space */
                background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23059669' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") center 18px / 20px 20px no-repeat,
                            linear-gradient(to bottom, rgba(248, 250, 252, 0.15) 0%, rgba(248, 250, 252, 0.35) 30%, rgba(248, 250, 252, 0.65) 65%, #f8fafc 100%);
                pointer-events: none;
                z-index: 1;
            }
            
            .help-box.collapsed .help-title::after {
                display: none;
            }
            
            /* Explicitly set expanded state to override collapsed max-height */
            .help-box.expanded .help-text {
                max-height: none !important;
                overflow: visible !important;
            }
        }

        /* Celebration animations */
        .celebration-bar {
            background: linear-gradient(90deg, #10b981, #059669, #10b981) !important;
            background-size: 200% 100% !important;
            animation: celebration-shimmer 2s ease-in-out infinite;
        }

        @keyframes celebration-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .completion-title {
            color: white !important;
            font-weight: 700 !important;
            animation: celebration-bounce 0.6s ease-out;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .completion-content {
            text-align: center;
            padding: 2rem;
            background: none; /* Remove separate background to blend with wizard */
            border-radius: 0;
            margin: 0;
            animation: celebration-fade-in 0.8s ease-out;
            box-shadow: none;
        }

        /* Desktop-specific completion content styling */
        @media (min-width: 768px) {
            .completion-content {
                margin: 0 auto;
                max-width: 500px;
                padding: 2.5rem;
                background: none; /* Ensure no background on desktop */
            }
            
            .wizard.completion {
                position: sticky;
                top: 100px;
                z-index: 10;
            }
        }

        .celebration-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: white;
            font-weight: bold;
            animation: celebration-scale 0.8s ease-out;
        }

        .completion-message {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 0.5rem;
            animation: celebration-slide-up 0.8s ease-out 0.2s both;
        }

        .completion-subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.9);
            animation: celebration-slide-up 0.8s ease-out 0.4s both;
        }

        @keyframes celebration-bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes celebration-fade-in {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes celebration-scale {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes celebration-slide-up {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Completion card styling */
        .completion-card {
            animation: completion-glow 0.8s ease-out;
            transition: all 0.3s ease !important;
        }

        /* Desktop-specific completion card layout improvements */
        @media (min-width: 768px) {
            /* Target cards grid when wizard has completion class */
            .coach-layout .wizard.completion ~ section .cards-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(320px, 400px));
                justify-content: center;
                gap: 2rem;
                margin: 2rem auto 0 auto;
                padding: 0;
                max-width: 1200px;
            }
            
            /* Hide card count indicators during completion */
            .coach-layout .wizard.completion ~ section .desktop-card-count {
                display: none !important;
            }
            
            .coach-layout .wizard.completion ~ .mobile-scroll-indicator {
                display: none !important;
            }
            
            /* Completion card styling for desktop */
            .completion-card {
                max-width: 400px;
                width: 100%;
                margin: 0 auto;
            }
            
            .completion-card.single-card {
                max-width: 350px;
            }
            
            /* Center single completion card */
            .coach-layout .wizard.completion ~ section .cards-grid .completion-card:only-child {
                grid-column: 1 / -1;
                justify-self: center;
                max-width: 380px;
            }
        }

        /* Completion cards get elegant styling with subtle emphasis */
        .completion-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8fffe 100%);
            border: 1px solid #059669 !important;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            animation: subtle-glow 2s ease-out;
        }

        /* Enable image scaling for completion cards like regular cards */
        .completion-card .card-image {
            transition: transform 0.3s ease;
        }
        
        /* Disable completion card hover effects on mobile */
        @media (max-width: 768px) {
            .completion-card:hover {
                transform: none !important;
                box-shadow: 0 2px 12px rgba(0,0,0,0.08) !important;
                border: 1px solid #059669 !important;
            }
            
            .completion-card:hover .card-image {
                transform: none !important;
            }
        }

        @keyframes subtle-glow {
            0% { 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #e5e7eb;
            }
            50% {
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #059669;
            }
            100% { 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #059669;
            }
        }

        /* Extra emphasis for the single perfect card */
        .completion-card.single-card {
            animation: perfect-card-pulse 3s ease-out;
            background: linear-gradient(135deg, #ffffff 0%, #f0fdf9 50%, #f8fffe 100%);
            border: 1px solid #059669 !important;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
        }

        /* Disable single completion card hover effects on mobile */
        @media (max-width: 768px) {
            .completion-card.single-card:hover {
                border: 1px solid #059669 !important;
                box-shadow: 0 2px 12px rgba(0,0,0,0.08) !important;
            }
        }

        @keyframes perfect-card-pulse {
            0% { 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #e5e7eb;
            }
            30% {
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #059669;
            }
            100% { 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                border: 1px solid #059669;
            }
        }


        /* Add padding above footer */
        #footer-placeholder {
            padding-top: 3rem;
        }

        /* Ensure minimum height on desktop for better visual balance */
        @media (min-width: 768px) {
            .coach-container {
                min-height: 60vh;
            }
            
            /* Better desktop layout for completion state */
            .wizard.completion {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                border: 1px solid #059669;
                box-shadow: 0 8px 25px rgba(16, 185, 129, 0.25);
                position: sticky;
                top: 100px;
                z-index: 10;
            }
            
            /* Ensure proper spacing for results section in completion state */
            .coach-layout > section {
                position: relative;
            }
            
            /* Hide results bar completely during completion */
            .coach-layout .wizard.completion ~ section .results-bar {
                display: none !important;
            }
            
            /* Hide active filters during completion */
            .coach-layout .wizard.completion ~ section #active-filters-line {
                display: none !important;
            }
        }

        .card-item {
            position: relative;
        }

        /* Feature badge for special cards */
        .feature-badge {
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0 0 6px 0;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            line-height: 1;
            min-width: 80px;
            text-align: center;
            z-index: 10;
        }

        .card-item {
            position: relative;
        }

    </style>
</head>
<body>
    <div id="header-placeholder"></div>

    <div class="coach-container">

        <div class="coach-layout">
            <!-- Wizard -->
            <aside class="wizard" id="wizard">
                <div class="wizard-header">
                    <div class="wizard-title" id="wizard-question">Step-by-step</div>
                </div>
                <div class="progress"><span id="progress-bar"></span></div>

                <div id="steps-container"></div>

                <div class="help-box" id="help-box" aria-live="polite">
                    <div class="help-title" id="help-title">
                        Practical Advice
                        <span class="expand-icon">▼</span>
                    </div>
                    <div class="help-text" id="help-content">
                        <ul class="recommendation-list" style="margin: 0; padding: 0; list-style: none;">
                            <li><strong>Getting started</strong> – Answer the question above. Tips update here.</li>
                        </ul>
                    </div>
                </div>
                
                <div class="wizard-actions">
                    <button class="btn btn-secondary" id="back-btn">Back</button>
                    <button class="btn btn-primary" id="next-btn" style="display: none;">Next</button>
                </div>
            </aside>

            <!-- Mobile scroll indicator (only visible on mobile) -->
            <div class="mobile-scroll-indicator" id="mobile-scroll-indicator" style="display: none;">
                <div class="mobile-scroll-count" id="mobile-scroll-count">0 Cards</div>
                <div class="mobile-scroll-label">Fit Your Criteria So Far</div>
            </div>

            <!-- Results -->
            <section>
                <div class="results-bar">
                    <div>
                        <strong id="results-headline">Found <span id="results-display-count">0</span> cards</strong>
                        <span style="color:#64748b;"> of <span id="results-display-total">0</span> total</span>
                    </div>
                    <div class="tabs" id="mode-tabs" style="display:none;">
                        <button class="tab active" data-tab="cashback">Cash back (<span id="cashback-count">0</span>)</button>
                        <button class="tab" data-tab="travel">Travel (<span id="travel-count">0</span>)</button>
                    </div>
                </div>

                <div id="active-filters-line" class="results-bar" style="display:none;">
                    <div style="display:flex;gap:.5rem;flex-wrap:wrap;" id="active-filters-chips"></div>
                    <button class="btn btn-secondary" onclick="resetAllFilters()">Clear all</button>
                </div>

                <!-- Desktop card count indicator (only visible on desktop) -->
                <div class="desktop-card-count" id="desktop-card-count" style="display: none;">
                    <div class="desktop-card-count-number" id="desktop-card-count-number">0 Cards</div>
                    <div class="desktop-card-count-label">Fit Your Criteria So Far</div>
                </div>

                <div class="cards-grid" id="cards-grid"></div>
            </section>
        </div>
    </div>

    <div id="footer-placeholder"></div>

    <script>
    // --- Header/Footer loader (copied from cards.html for consistency) ---
    document.addEventListener('DOMContentLoaded', function() {
        loadComponent('header.html', 'header-placeholder');
        loadComponent('footer.html', 'footer-placeholder');
        initializeCards().then(() => { initCoach(); });
    });

    function loadComponent(filename, placeholderId) {
        const placeholder = document.getElementById(placeholderId);
        fetch(filename).then(r => r.text()).then(html => {
            if (filename === 'header.html') {
                const cleanHtml = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                placeholder.innerHTML = cleanHtml;
                const scripts = [...html.matchAll(/<script[^>]*>([\s\S]*?)<\/script>/gi)].map(m=>m[1]);
                scripts.forEach(s => { try { eval(s); } catch(e) { console.error(e); } });
                
                // Auto-scroll down past the header after it's loaded (mobile only)
                setTimeout(() => {
                    // Only auto-scroll on mobile devices (viewport width <= 1024px)
                    if (window.innerWidth <= 1024) {
                        const header = document.querySelector('header');
                        if (header) {
                            const headerHeight = header.offsetHeight;
                            window.scrollTo({
                                top: headerHeight,
                                behavior: 'smooth'
                            });
                        }
                    }
                }, 50);
            } else { placeholder.innerHTML = html; }
        }).catch(() => { placeholder.innerHTML = ''; });
    }

    // --- Cards data, rendering, filters (trimmed/adapted from cards.html) ---
    let allCards = [];
    let filteredCards = [];
    let cardsCache = null;
    let isLoading = false;

    async function initializeCards() {
        // Prevent multiple simultaneous requests
        if (isLoading) {
            console.log('🔄 Cards already loading, skipping duplicate request');
            return;
        }
        
        // Show loading state immediately
        showLoadingState();
        
        // Check cache first (valid for 5 minutes)
        if (cardsCache && Date.now() - cardsCache.timestamp < 300000) {
            console.log('✅ Using cached cards data');
            allCards = cardsCache.data;
            filteredCards = [...allCards];
            renderCards(filteredCards);
            updateResultsHeadline(filteredCards.length, allCards.length);
            hideLoadingState();
            return;
        }
        
        isLoading = true;
        
        try {
            console.log('📥 Fetching cards.json...');
            
            const response = await fetch('cards.json', { cache: 'no-store' });
            if (!response.ok) {
                throw new Error(`Failed to fetch cards.json: ${response.status}`);
            }
            
            const databaseCards = await response.json();
            console.log('✅ Static JSON fetch successful, received cards:', databaseCards);
            
            // Convert database format to match your existing code (same as cards.html)
            let allCardsFromDB = databaseCards.map(card => {
                // Helper function to safely parse array data
                const parseArrayField = (field) => {
                    if (!field || field === '0' || field === 0) {
                        return [];
                    }
                    if (Array.isArray(field)) {
                        return field;
                    }
                    if (typeof field === 'string') {
                        try {
                            // Handle double-encoded JSON strings and malformed data
                            let cleanField = field.trim();
                            
                            // Remove surrounding quotes if they exist
                            if (cleanField.startsWith('"') && cleanField.endsWith('"')) {
                                cleanField = cleanField.slice(1, -1);
                            }
                            
                            // Handle cases where the inner content is still quoted
                            if (cleanField.startsWith('"[') && cleanField.endsWith(']"')) {
                                cleanField = cleanField.slice(1, -1);
                            }
                            
                            const parsed = JSON.parse(cleanField);
                            
                            // Clean up any quoted strings within the array
                            if (Array.isArray(parsed)) {
                                return parsed.map(item => {
                                    if (typeof item === 'string' && item.startsWith('"') && item.endsWith('"')) {
                                        return item.slice(1, -1);
                                    }
                                    return item;
                                });
                            }
                            
                            return Array.isArray(parsed) ? parsed : [];
                        } catch (e) {
                            console.warn('Failed to parse array field:', field, e);
                            return [];
                        }
                    }
                    return [];
                };
                
                return {
                    id: card.id,
                    name: card.name,
                    type: card.type,
                    annualFee: card.annual_fee,
                    bankType: card.bank_type,
                    rewards: card.rewards_type,
                    image: card.image_url,
                    welcomeBonus: card.welcome_bonus || card.welcomeBonus || 'None',
                    practicalAdvice: card.practical_advice || card.practicalAdvice || '',
                    features: Array.isArray(card.features) ? card.features : parseArrayField(card.features),
                    perkCategories: parseArrayField(card.perk_categories),
                    protectionCategories: parseArrayField(card.protection_categories),
                    earningCategories: parseArrayField(card.earning_categories),
                    airlineHotel: parseArrayField(card.airline_hotels),
                    url: card.card_url,
                    status: card.status || 'active'
                };
            });
            
            // Filter to only show active cards
            allCards = allCardsFromDB.filter(card => card.status === 'active');
            
            // Cache the results
            cardsCache = {
                data: allCards,
                timestamp: Date.now()
            };
            
            console.log('✅ Loaded cards from static JSON:', allCards.length);
        } catch (e) {
            console.warn('Failed to load cards from database:', e && e.message);
            
            // Show error state instead of fallback cards
            showErrorState(e.message);
        } finally {
            isLoading = false;
            hideLoadingState();
        }
        
        filteredCards = [...allCards];
        renderCards(filteredCards);
        updateResultsHeadline(filteredCards.length, allCards.length);
    }

    function showLoadingState() {
        const cardsGrid = document.getElementById('cards-grid');
        if (cardsGrid) {
            cardsGrid.innerHTML = `
                <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #fff; border-radius: 12px; border: 1px solid #e5e7eb;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <div style="width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top: 3px solid #059669; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="color: #1e293b; font-weight: 600;">Loading credit cards...</div>
                        <div style="color: #64748b; font-size: 0.875rem;">Please wait while we fetch the latest data</div>
                    </div>
                </div>
            `;
            
            // Add CSS animation if not already present
            if (!document.getElementById('loading-spinner-css')) {
                const style = document.createElement('style');
                style.id = 'loading-spinner-css';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
        }
    }

    function hideLoadingState() {
        // The loading state will be replaced when renderCards() is called
        // No need to explicitly hide it here
    }

    function showErrorState(errorMessage) {
        const cardsGrid = document.getElementById('cards-grid');
        if (cardsGrid) {
            cardsGrid.innerHTML = `
                <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #fff; border-radius: 12px; border: 1px solid #e5e7eb;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <div style="width: 48px; height: 48px; background: #fef2f2; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">⚠️</div>
                        <div style="color: #1e293b; font-weight: 600; font-size: 1.125rem;">Unable to load credit cards</div>
                        <div style="color: #64748b; font-size: 0.875rem; max-width: 400px; line-height: 1.5;">
                            We're having trouble connecting to our database. Please check your internet connection and try refreshing the page.
                        </div>
                        <button onclick="window.location.reload()" style="
                            background: #059669; 
                            color: white; 
                            border: none; 
                            padding: 0.75rem 1.5rem; 
                            border-radius: 8px; 
                            font-weight: 600; 
                            cursor: pointer;
                            font-size: 0.875rem;
                        ">Refresh Page</button>
                    </div>
                </div>
            `;
        }
        
        // Clear the cards arrays so nothing renders
        allCards = [];
        filteredCards = [];
        updateResultsHeadline(0, 0);
    }



    function generatePracticalAdvice(card) {
        // Use database practical advice if available, otherwise generate it
        if (card.practical_advice || card.practicalAdvice) {
            return card.practical_advice || card.practicalAdvice;
        }
        // Generate practical advice based on card characteristics (same logic as cards.html)
        if (card.annualFee === 0) {
            if (card.type === 'cashback') {
                return "Perfect starter card with no risk. Use for everyday spending and build credit history.";
            } else if (card.type === 'hybrid') {
                return "Great for renters! Pay rent with this card to earn points on your biggest monthly expense.";
            } else {
                return "No annual fee means this card pays for itself. Great for building credit and earning rewards.";
            }
        } else if (card.annualFee <= 95) {
            if (card.type === 'travel') {
                return "Low annual fee for solid travel benefits. Make sure you'll use the credits to offset the cost.";
            } else {
                return "Modest annual fee for enhanced rewards. Calculate if the extra earning rates justify the cost.";
            }
        } else if (card.annualFee <= 250) {
            if (card.name.includes('Venture X')) {
                return "At $395/year, this is premium travel at a discount. The $300 travel credit + 10k anniversary miles make it worth it if you travel 2+ times per year.";
            } else {
                return "Premium card with significant annual fee. Only worth it if you travel frequently and will use all the credits and benefits.";
            }
        } else {
            if (card.name.includes('Platinum')) {
                return "The $695 fee is steep, but the credits add up quickly. Only get this if you'll use airline credits, hotel credits, and lounge access regularly.";
            } else if (card.name.includes('Reserve')) {
                return "At $795/year, this is Chase's premium offering. The $300 travel credit helps, but you need to travel frequently to justify this cost.";
            } else {
                return "High annual fee card. Carefully calculate if the benefits outweigh the cost for your specific spending patterns.";
            }
        }
    }

    function createCardElement(card) {
        const div = document.createElement('div');
        div.className = 'card-item';
        div.onclick = () => window.location.href = card.url;
        const feeText = card.annualFee === 0 ? 'Annual Fee: $0' : `Annual Fee: $${card.annualFee}`;
        const welcomeBonus = card.welcomeBonus || 'None';
        const earningRates = Array.isArray(card.features) ? card.features.slice(0,3).join(' • ') : '';
        // Intentionally do not render filter tags on the card in Card Coach
        const advice = generatePracticalAdvice(card);

        div.innerHTML = `
            <img src="${card.image}" alt="${card.name}" class="card-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="card-image-fallback" style="display: none;">${card.name}</div>
            
            <div class="card-header">
                <h3 class="card-title">${card.name}</h3>
            </div>
            
            <div class="card-meta-row">
                <span class="meta-chip">${feeText}</span>
                <span class="meta-chip">Welcome: ${welcomeBonus}</span>
            </div>
            
            <div class="card-earning-rates">
                <strong>Earning:</strong> ${earningRates || '1x on everything'}
            </div>
            
            <div class="card-advice">
                <div class="card-advice-label">Practical Advice</div>
                <div class="card-advice-text">${advice}</div>
            </div>
        `;
        return div;
    }

    function createFeaturedCardElement(card) {
        const div = document.createElement('div');
        div.className = 'card-item';
        div.onclick = () => window.location.href = card.url;
        const feeText = card.annualFee === 0 ? 'Annual Fee: $0' : `Annual Fee: $${card.annualFee}`;
        const welcomeBonus = card.welcomeBonus || 'None';
        const earningRates = Array.isArray(card.features) ? card.features.slice(0,3).join(' • ') : '';
        const advice = generatePracticalAdvice(card);

        // Add feature badge for special cards in featured section only
        let badgeHtml = '';
        if (card.id === 1) { // Venture X
            badgeHtml = '<div class="feature-badge">Travel</div>';
        } else if (card.id === 6) { // Active Cash
            badgeHtml = '<div class="feature-badge">Cash Back</div>';
        }

        div.innerHTML = `
            ${badgeHtml}
            <img src="${card.image}" alt="${card.name}" class="card-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="card-image-fallback" style="display: none;">${card.name}</div>
            
            <div class="card-header">
                <h3 class="card-title">${card.name}</h3>
            </div>
            
            <div class="card-meta-row">
                <span class="meta-chip">${feeText}</span>
                <span class="meta-chip">Welcome: ${welcomeBonus}</span>
            </div>
            
            <div class="card-earning-rates">
                <strong>Earning:</strong> ${earningRates || '1x on everything'}
            </div>
            
            <div class="card-advice">
                <div class="card-advice-label">Practical Advice</div>
                <div class="card-advice-text">${advice}</div>
            </div>
        `;
        return div;
    }

    function isCompletionStep() {
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        return currentStep && currentStep.type === 'completion';
    }

    function forceCompletionStyling() {
        // Completion styling is now handled entirely by CSS classes
        // Just ensure the completion-card classes are properly applied
        const cards = document.querySelectorAll('.card');
        cards.forEach(cardElement => {
            if (cardElement.classList.contains('completion-card')) {
                // Remove any inline styles that might override our CSS
                cardElement.style.border = '';
                cardElement.style.boxShadow = '';
                cardElement.style.transform = '';
            }
        });
    }

    let currentCards = []; // Track currently displayed cards for animation

    function renderCards(cards) {
        const grid = document.getElementById('cards-grid');
        grid.classList.remove('showing-intro');
        
        const isCompletion = isCompletionStep();
        
        // Get currently displayed card IDs
        const currentCardIds = new Set(currentCards.map(c => c.id));
        const newCardIds = new Set(cards.map(c => c.id));
        
        // Find cards to remove and cards to add
        const cardsToRemove = currentCards.filter(c => !newCardIds.has(c.id));
        const cardsToAdd = cards.filter(c => !currentCardIds.has(c.id));
        const cardsToKeep = cards.filter(c => currentCardIds.has(c.id));
        
        // If this is the first render, zero cards, or currentCards was reset, just render immediately
        if (currentCards.length === 0 || cards.length === 0) {
            renderCardsImmediate(cards, isCompletion);
            currentCards = [...cards];
            // Ensure indicators update on immediate render paths
            if (!isCompletion) {
                updateMobileScrollIndicator(cards);
                updateDesktopCardCount(cards);
            }
            return;
        }
        
        // For filter changes (like going back), always do immediate render to avoid animation issues
        if (cardsToAdd.length > 5 || cardsToRemove.length > 5) {
            renderCardsImmediate(cards, isCompletion);
            currentCards = [...cards];
            // Ensure indicators update on immediate render paths
            if (!isCompletion) {
                updateMobileScrollIndicator(cards);
                updateDesktopCardCount(cards);
            }
            return;
        }
        
        // Handle animated transitions
        if (cardsToRemove.length > 0 || cardsToAdd.length > 0) {
            handleAnimatedCardTransition(cardsToRemove, cardsToAdd, cardsToKeep, isCompletion);
        }
        
        currentCards = [...cards];

        // Update mobile scroll indicator (but not during completion)
        if (!isCompletion) {
            updateMobileScrollIndicator(cards);
        }

        // Update desktop card count (but not during completion)
        if (!isCompletion) {
            updateDesktopCardCount(cards);
        }
    }
    
    function renderCardsImmediate(cards, isCompletion) {
        const grid = document.getElementById('cards-grid');
        grid.innerHTML = '';
        
        cards.forEach((c, index) => {
            const cardElement = createCardElement(c);
            
            // Add special styling for completion step
            if (isCompletion) {
                cardElement.classList.add('completion-card');
                
                // Add extra emphasis if this is the single perfect card
                if (cards.length === 1) {
                    cardElement.classList.add('single-card');
                }
            } else {
                // Add fade-in animation for new cards
                cardElement.classList.add('fade-in');
                // Remove the animation class after animation completes
                setTimeout(() => {
                    cardElement.classList.remove('fade-in');
                }, 500 + (index * 50)); // Account for stagger delay
            }
            
            grid.appendChild(cardElement);
        });
    }
    
    function handleAnimatedCardTransition(cardsToRemove, cardsToAdd, cardsToKeep, isCompletion) {
        const grid = document.getElementById('cards-grid');
        const totalNewCards = cardsToAdd.length;
        
        // Set adaptive stagger class based on number of cards
        grid.className = grid.className.replace(/\b(fast|normal)-stagger\b/g, '');
        if (totalNewCards > 8) {
            grid.classList.add('fast-stagger');
        } else {
            grid.classList.add('normal-stagger');
        }
        
        // Use requestAnimationFrame for smooth animations
        if (cardsToRemove.length > 0) {
            // Batch fade-out operations
            requestAnimationFrame(() => {
                const existingElements = Array.from(grid.children);
                const elementsToFadeOut = [];
                
                existingElements.forEach(element => {
                    const cardId = element.querySelector('.card-title')?.textContent;
                    if (cardsToRemove.some(c => c.name === cardId)) {
                        element.classList.add('fade-out');
                        elementsToFadeOut.push(element);
                    }
                });
                
                // Wait for fade-out animation to complete
                if (elementsToFadeOut.length > 0) {
                    // Use transitionend event for better timing
                    let completedTransitions = 0;
                    const onTransitionEnd = () => {
                        completedTransitions++;
                        if (completedTransitions >= elementsToFadeOut.length) {
                            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                        }
                    };
                    
                    elementsToFadeOut.forEach(element => {
                        element.addEventListener('transitionend', onTransitionEnd, { once: true });
                    });
                    
                    // Fallback timeout in case transitionend doesn't fire
                    setTimeout(() => {
                        if (completedTransitions < elementsToFadeOut.length) {
                            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                        }
                    }, 300);
                } else {
                    updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                }
            });
        } else {
            // No cards to remove, add new ones immediately
            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
        }
    }
    
    function updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion) {
        const grid = document.getElementById('cards-grid');
        
        // Batch DOM operations for better performance
        requestAnimationFrame(() => {
            // Remove faded out cards in one batch
            const elementsToRemove = Array.from(grid.querySelectorAll('.fade-out'));
            elementsToRemove.forEach(element => element.remove());
            
            // Create all new card elements before adding to DOM
            const newElements = cardsToAdd.map((card, index) => {
                const cardElement = createCardElement(card);
                
            if (isCompletion) {
                cardElement.classList.add('completion-card');
                
                // Add extra emphasis if this is the single perfect card
                const allCards = [...cardsToAdd, ...cardsToKeep];
                if (allCards.length === 1) {
                    cardElement.classList.add('single-card');
                }
            } else {
                    // Set initial invisible state for smooth fade-in
                    cardElement.style.opacity = '0';
                    cardElement.style.transform = 'translateY(10px)';
                }
                
                return cardElement;
            });
            
            // Add all elements to DOM in one batch operation
            const fragment = document.createDocumentFragment();
            newElements.forEach(element => fragment.appendChild(element));
            grid.appendChild(fragment);
            
            // Trigger smooth staggered fade-in
            if (!isCompletion && newElements.length > 0) {
                newElements.forEach((element, index) => {
                    setTimeout(() => {
                        requestAnimationFrame(() => {
                            element.classList.add('fade-in');
                        });
                    }, index * 50);
                });
            }
        });
    }

    function showIntroText() {
        const grid = document.getElementById('cards-grid');
        grid.classList.add('showing-intro');
        currentCards = []; // Reset current cards state when showing intro
        
        // Get featured cards data
        const featuredCardIds = [1, 6]; // Venture X, Active Cash
        const featuredCards = allCards.filter(card => featuredCardIds.includes(card.id));
        
        // Create featured cards HTML using special featured card elements (with badges)
        let featuredCardsHTML = '';
        if (featuredCards.length > 0) {
            const featuredCardElements = featuredCards.map(card => {
                const cardElement = createFeaturedCardElement(card);
                return cardElement.outerHTML;
            }).join('');
            
            featuredCardsHTML = `
                <div style="margin-top: 2rem;">
                    <h3 style="color: #047857; font-size: 1.3rem; font-weight: 600; margin-bottom: 1.5rem; text-align: center;">Featured Picks</h3>
                    <div class="cards-grid" style="margin-bottom: 0;">
                        ${featuredCardElements}
                    </div>
                </div>
            `;
        }
        
        grid.innerHTML = `
            <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #059669; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.15);">
                <h2 style="color: white; margin-bottom: 1.5rem; font-size: 1.5rem; font-weight: 600;">We built Practical Picks to help you find the right card for your life.</h2>
                <p style="color: white; opacity: 0.9; font-size: 1rem; line-height: 1.6; margin-bottom: 1rem;">
                    Answer a few quick questions and tell us what matters—cash back, travel, lounges, no foreign fees, or keeping it simple. Then we put our practical research to work and surface cards that actually fit your goals.
                </p>
                <p style="color: white; opacity: 0.9; font-size: 1rem; line-height: 1.6; margin: 0;">
                    The result? Clear, personalized options you can choose from.
                </p>
            </div>
            ${featuredCardsHTML}
        `;

        // Re-add click handlers to featured cards since innerHTML strips them
        if (featuredCards.length > 0) {
            const featuredCardElements = grid.querySelectorAll('.card-item');
            featuredCardElements.forEach((cardElement, index) => {
                if (index < featuredCards.length) {
                    const card = featuredCards[index];
                    cardElement.onclick = () => window.location.href = card.url;
                    cardElement.style.cursor = 'pointer';
                }
            });
        }

        // Hide mobile scroll indicator when showing intro
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        if (mobileIndicator) {
            mobileIndicator.style.display = 'none';
        }

        // Hide desktop card count when showing intro
        const desktopIndicator = document.getElementById('desktop-card-count');
        if (desktopIndicator) {
            desktopIndicator.style.display = 'none';
        }
    }

    function updateResultsHeadline(count, total) {
        const c = document.getElementById('results-display-count');
        const t = document.getElementById('results-display-total');
        if (c) c.textContent = count; 
        if (t) t.textContent = total;
    }

    function updateResultsHeadlineForQuiz() {
        const headline = document.getElementById('results-headline');
        if (headline) {
            headline.innerHTML = 'Find your perfect card';
        }
    }

    // --- Filtering helpers (map to existing data fields) ---
    function getIssuerCategory(card) {
        const b = (card.bankType || '').toLowerCase();
        const n = (card.name || '').toLowerCase();
        if (b.includes('amex') || n.includes('american express')) return 'amex';
        if (b.includes('chase') || n.includes('chase')) return 'chase';
        if (b.includes('capital-one') || n.includes('capital one') || n.includes('venture')) return 'capital-one';
        if (b.includes('citi') || n.includes('citi')) return 'citi';
        if (b.includes('discover') || n.includes('discover')) return 'discover';
        if (b.includes('wells') || n.includes('wells fargo')) return 'wells-fargo';
        return 'other';
    }

    function inferBrandTags(card) {
        const name = (card.name || '').toLowerCase();
        const tags = new Set(Array.isArray(card.airlineHotel) ? card.airlineHotel.map(v => (v||'').toLowerCase()) : []);
        const brandMap = {
            'delta':'delta', 'united':'united', 'aa ':'american', 'aadvantage':'american',
            'southwest':'southwest', 'jetblue':'jetblue', 'alaska':'alaska',
            'marriott':'marriott', 'hilton':'hilton', 'hyatt':'hyatt', 'ihg':'ihg', 'wyndham':'wyndham', 'choice':'choice'
        };
        
        // Special handling for American Airlines to avoid false positives with American Express
        if (name.includes('american airlines') || name.includes('aa ') || name.includes('aadvantage')) {
            tags.add('american');
        }
        
        // Check other brands (excluding 'american' to avoid American Express false positives)
        Object.keys(brandMap).forEach(k => { 
            if (k !== 'american' && name.includes(k)) {
                tags.add(brandMap[k]); 
            }
        });
        
        return Array.from(tags);
    }

    function applyFiltersTo(cards, filters) {
        return cards.filter(card => {
            // First, apply flat-rate exclusion if user has a 2% everywhere card
            if (state.cashbackFilters.hasFlatRate) {
                const earningCats = Array.isArray(card.earningCategories) ? card.earningCategories : [];
                if (earningCats.includes('flat-rate')) {
                    console.log(`❌ ${card.name} filtered out - user already has 2% everywhere card, excluding flat-rate`);
                    return false;
                }
                // Also check for "flat-rate" with quotes (in case of double encoding)
                if (earningCats.includes('"flat-rate"')) {
                    console.log(`❌ ${card.name} filtered out - user already has 2% everywhere card, excluding "flat-rate"`);
                    return false;
                }
            }

            for (const [k, values] of Object.entries(filters)) {
                if (!values || values.length === 0) continue;
                if (k === 'type') {
                    // Handle arrays, single strings, and JSON-stringified arrays
                    let cardType;
                    if (Array.isArray(card.type)) {
                        cardType = card.type;
                    } else if (typeof card.type === 'string' && card.type.trim().startsWith('[') && card.type.trim().endsWith(']')) {
                        try { cardType = JSON.parse(card.type); } catch(e) { cardType = [card.type]; }
                    } else {
                        cardType = [card.type];
                    }
                    if (!values.some(v => cardType.includes(v))) return false;
                } else if (k === 'issuer') {
                    if (!values.includes(getIssuerCategory(card))) return false;
                } else if (k === 'perks') {
                    const perks = card.perkCategories || [];
                    console.log(`🔍 Filtering ${card.name} for perks:`, values, 'Card has perks:', perks);
                    // Use OR logic for perks - card must have ANY selected perk
                    const hasAnyPerk = values.some(v => perks.includes(v));
                    if (!hasAnyPerk) {
                        console.log(`❌ ${card.name} filtered out - missing any required perk(s)`);
                        return false;
                    }
                } else if (k === 'protections') {
                    const prots = card.protectionCategories || [];

                    // Function to check if a protection matches (handles variations)
                    const protectionMatches = (selectedProtection, cardProtections) => {
                        // Direct match
                        if (cardProtections.includes(selectedProtection)) return true;
                        
                        // Handle trip delay variations
                        if (selectedProtection === 'trip-delay-cancellation') {
                            return cardProtections.some(p => 
                                p === 'trip-delay' || 
                                p === 'trip-cancellation-interruption' ||
                                p === 'trip-delay-cancellation'
                            );
                        }
                        
                        // Handle baggage protection variations
                        if (selectedProtection === 'lost-delayed-baggage') {
                            return cardProtections.some(p => 
                                p === 'lost-delayed-baggage' || 
                                p === 'baggage-delay' ||
                                p === 'lost-damaged-luggage'
                            );
                        }
                        
                        return false;
                    };

                    // Strict mode: card must have ALL of the selected protections
                    let allMatches = true;
                    for (const selectedValue of values) {
                        if (!protectionMatches(selectedValue, prots)) {
                            allMatches = false;
                            break;
                        }
                    }

                    if (!allMatches) return false;
                } else if (k === 'airline-hotel') {
                    const brandsOnCard = inferBrandTags(card);
                    if (!values.some(v => brandsOnCard.includes(v))) return false;
                } else if (k === 'earning_any') {
                    const earningCats = Array.isArray(card.earningCategories) ? card.earningCategories : [];

                    console.log(`🔍 Filtering ${card.name} for earning_any:`, values, 'Card has earning categories:', earningCats);

                    // Exclude Citi Custom Cash when 2+ categories selected (it can only do 1 category)
                    if (values.length >= 2 && card.name === 'Citi Custom Cash® Card') {
                        console.log(`❌ ${card.name} filtered out - can only handle 1 category, ${values.length} selected`);
                        return false;
                    }

                    // Strict mode: card must have ALL of the selected categories/groups
                    let allMatches = true;

                    for (const selectedValue of values) {
                        // Handle grouped categories (e.g., "gas|ev-charging")
                        const selectedOptions = selectedValue.split('|');
                        const hasMatchForGroup = selectedOptions.some(option => earningCats.includes(option));

                        if (!hasMatchForGroup) {
                            allMatches = false;
                            break;
                        }
                    }

                    console.log(`🔍 ${card.name} strict mode: ${allMatches ? 'matches all' : 'missing some'} categories`);

                    if (!allMatches) {
                        console.log(`❌ ${card.name} filtered out - needs ALL matching categories`);
                        return false;
                    } else {
                        console.log(`✅ ${card.name} passed strict earning filter`);
                    }
                } else if (k === 'fee') {
                    if (values.includes('0-100') && !(card.annualFee >= 0 && card.annualFee <= 100)) return false;
                    if (values.includes('100-300') && !(card.annualFee >= 100 && card.annualFee <= 300)) return false;
                    if (values.includes('300-500') && !(card.annualFee >= 300 && card.annualFee <= 500)) return false;
                    if (values.includes('500+') && !(card.annualFee >= 500)) return false;
                } else if (k === 'focus') {
                    const brandsOnCard = inferBrandTags(card);
                    const hasAirlineOrHotelBrand = brandsOnCard.length > 0;
                    
                    if (values.includes('flex')) {
                        // For flexible points, exclude cards with any airline or hotel brands
                        if (hasAirlineOrHotelBrand) {
                            console.log(`❌ ${card.name} filtered out - has airline/hotel brand(s): ${brandsOnCard.join(', ')}, not flexible points`);
                            return false;
                        }
                    } else if (values.includes('airline')) {
                        // For airline cards, only show cards with airline brands
                        const airlineBrands = ['delta', 'united', 'american', 'southwest', 'jetblue', 'alaska'];
                        const hasAirlineBrand = brandsOnCard.some(brand => airlineBrands.includes(brand));
                        if (!hasAirlineBrand) {
                            console.log(`❌ ${card.name} filtered out - not an airline card`);
                            return false;
                        }
                    } else if (values.includes('hotel')) {
                        // For hotel cards, only show cards with hotel brands
                        const hotelBrands = ['marriott', 'hilton', 'hyatt', 'ihg', 'wyndham', 'choice'];
                        const hasHotelBrand = brandsOnCard.some(brand => hotelBrands.includes(brand));
                        if (!hasHotelBrand) {
                            console.log(`❌ ${card.name} filtered out - not a hotel card`);
                            return false;
                        }
                    }
                }
            }
            return true;
        });
    }

    // --- Coach state & flow ---
    const state = {
        stepIndex: 0,
        steps: [],
        mode: null,  // travel | cashback | either
        baseFilters: {},
        travelFilters: {},
        cashbackFilters: {},
        activeTab: 'cashback',
        lastApplied: null
    };

    function generateFollowUpCategoryStep(mode, stepId, excludeCategory) {
        // Get available categories excluding the one already selected
        const allCategories = {
            'flat-rate': { label: 'Flat Rate', value: 'flat-rate' },
            'rent': { label: 'Rent', value: 'rent' },
            'dining': { label: 'Dining / Bars', value: 'dining' },
            'groceries': { label: 'Groceries', value: 'groceries' },
            'gas|ev-charging': { label: 'Gas/EV Charging', value: 'gas|ev-charging' },
            'travel|hotels|airlines': { label: 'Travel', value: 'travel|hotels|airlines' },
            'rideshare|transit': { label: 'Rideshare/Transit', value: 'rideshare|transit' },
            'streaming': { label: 'Streaming', value: 'streaming' },
            'drugstores': { label: 'Drugstores', value: 'drugstores' },
            'entertainment': { label: 'Entertainment', value: 'entertainment' },
            'wholesale-clubs': { label: 'Wholesale Clubs', value: 'wholesale-clubs' },
            'amazon': { label: 'Amazon', value: 'amazon' }
        };
        
        // Get current filters and cards
        const currentFilters = mode === 'travel' ? state.travelFilters : state.cashbackFilters;
        const baseFilter = {};
        if (mode === 'cashback') baseFilter.type = ['cashback'];
        if (mode === 'travel') baseFilter.type = ['travel'];
        const mergedFilters = mergeFilters(baseFilter, currentFilters);
        const currentCards = applyFiltersTo(allCards, mergedFilters);
        
        // Only show this step if there are multiple cards
        if (currentCards.length <= 1) return null;
        
        // Get available additional categories (excluding the already selected one)
        const additionalCategories = [];
        Object.entries(allCategories).forEach(([key, categoryInfo]) => {
            // Skip the already selected category
            if (key === excludeCategory || (excludeCategory && excludeCategory.includes(key))) return;
            
            // Skip categories that don't apply to this mode
            if (mode === 'cashback' && key === 'rent') return;
            if (mode === 'cashback' && (key === 'wholesale-clubs' || key === 'amazon')) {
                // Include these for cashback
            } else if (mode === 'travel' && (key === 'wholesale-clubs' || key === 'amazon')) {
                return; // Skip these for travel mode
            }
            
            // Test if adding this category would still leave us with cards
            const testFilter = { ...mergedFilters };
            const currentEarning = testFilter.earning_any || [];
            testFilter.earning_any = [...currentEarning, key];
            const cardsWithBothCategories = applyFiltersTo(allCards, testFilter);
            
            if (cardsWithBothCategories.length > 0) {
                additionalCategories.push(categoryInfo);
            }
        });
        
        // Only create the step if we have additional categories
        if (additionalCategories.length === 0) return null;
        
        // Add the "No preference" option at the top
        const skipToProtectionsOption = {
            label: `<div class="text-content skip-option"><strong>No preference</strong></div>`,
            value: 'skip-to-protections'
        };
        
        // Add the skip option at the end
        const allOptions = [...additionalCategories, skipToProtectionsOption];
        
        return {
            id: stepId,
            branch: mode,
            title: mode === 'cashback' ? 'Any other cash back categories?' : 'Any other rewards categories?',
            tip: 'Pick an additional category to find cards that excel in multiple areas.',
            type: 'radio',
            options: allOptions,
            help: 'Select an additional category where you want good earning rates. Cards that excel in multiple categories give you more flexibility.',
            onAnswer: (val) => {
                if (val === 'skip-to-protections') {
                    // Don't modify earning categories, just skip to protections
                    state.lastApplied = { key: 'skip-to-protections', value: true };
                    return;
                }
                
                const currentFilters = mode === 'travel' ? state.travelFilters : state.cashbackFilters;
                const currentEarning = currentFilters.earning_any || [];
                const newEarning = [...currentEarning, val];
                currentFilters.earning_any = Array.from(new Set(newEarning)); // Remove duplicates
                state.lastApplied = { key: 'earning_any', value: val };
            }
        };
    }

    function getAvailableProtections(mode) {
        console.log(`🛡️ getAvailableProtections called for mode: ${mode}`);
        
        // Define all possible protections with their labels and values
        const allProtections = {
            'cell-phone-protection': { label: '<div class="text-content"><strong>Phone protection</strong></div>', value: 'cell-phone-protection' },
            'purchase-protection': { label: '<div class="text-content"><strong>Purchase protection & extended warranty</strong></div>', value: 'purchase-protection' },
            'trip-delay-cancellation': { label: '<div class="text-content"><strong>Trip Delay or Cancellation</strong></div>', value: 'trip-delay-cancellation' },
            'rental-car-insurance': { label: '<div class="text-content"><strong>Rental Car Insurance</strong></div>', value: 'rental-car-insurance' },
            'lost-delayed-baggage': { label: '<div class="text-content"><strong>Lost or Delayed Baggage</strong></div>', value: 'lost-delayed-baggage' }
        };
        
        // Get the base filter for the mode
        const baseFilter = {};
        if (mode === 'cashback') baseFilter.type = ['cashback'];
        if (mode === 'travel') baseFilter.type = ['travel'];
        
        // Get current filters (without protections to test each one)
        const currentFilters = mode === 'travel' ? state.travelFilters : state.cashbackFilters;
        const testFilters = { ...currentFilters };
        delete testFilters.protections; // Remove protections filter to test each one
        
        const mergedBase = mergeFilters(baseFilter, testFilters);
        
        // Test each protection to see if it has available cards
        const availableProtections = [];
        
        Object.entries(allProtections).forEach(([key, protectionInfo]) => {
            // Skip protections that don't apply to this mode
            if (mode === 'cashback' && (key === 'trip-delay-cancellation' || key === 'rental-car-insurance' || key === 'lost-delayed-baggage')) {
                return; // Skip travel protections for cashback mode
            }
            if (mode === 'travel' && (key === 'cell-phone-protection' || key === 'purchase-protection')) {
                return; // Skip cashback protections for travel mode
            }
            
            // Test if this protection has any cards
            const testFilter = { ...mergedBase, protections: [key] };
            const cardsWithProtection = applyFiltersTo(allCards, testFilter);
            
            console.log(`🔍 Testing protection "${key}": ${cardsWithProtection.length} cards available`);
            console.log(`   Test filter:`, testFilter);
            if (cardsWithProtection.length > 0) {
                console.log(`   ✅ Adding protection "${key}" to available options`);
                availableProtections.push(protectionInfo);
            } else {
                console.log(`   ❌ Skipping protection "${key}" - no cards available`);
            }
        });
        
        // Add the "I don't care about any protections" option at the end
        const skipProtectionsOption = {
            label: `<div class="text-content skip-option"><strong>No preference</strong></div>`,
            value: 'skip-protections'
        };
        availableProtections.push(skipProtectionsOption);
        
        console.log(`🎯 Returning ${availableProtections.length} available protections:`, availableProtections);
        return availableProtections;
    }

    function getAvailableEarningCategories(mode) {
        // Define all possible categories with their labels and values
        const allCategories = {
            'flat-rate': { label: 'Flat Rate', value: 'flat-rate' },
            'rent': { label: 'Rent', value: 'rent' },
            'dining': { label: 'Dining / Bars', value: 'dining' },
            'groceries': { label: 'Groceries', value: 'groceries' },
            'gas|ev-charging': { label: 'Gas/EV Charging', value: 'gas|ev-charging' },
            'travel|hotels|airlines': { label: 'Travel', value: 'travel|hotels|airlines' },
            'rideshare|transit': { label: 'Rideshare/Transit', value: 'rideshare|transit' },
            'streaming': { label: 'Streaming', value: 'streaming' },
            'drugstores': { label: 'Drugstores', value: 'drugstores' },
            'entertainment': { label: 'Entertainment', value: 'entertainment' },
            'wholesale-clubs': { label: 'Wholesale Clubs', value: 'wholesale-clubs' },
            'amazon': { label: 'Amazon', value: 'amazon' }
        };
        
        // Get the base filter for the mode
        const baseFilter = {};
        if (mode === 'cashback') baseFilter.type = ['cashback'];
        if (mode === 'travel') baseFilter.type = ['travel'];
        
        // Get current filters (without earning_any to test each category)
        const currentFilters = mode === 'travel' ? state.travelFilters : state.cashbackFilters;
        const testFilters = { ...currentFilters };
        delete testFilters.earning_any; // Remove earning category filter to test each one
        
        const mergedBase = mergeFilters(baseFilter, testFilters);
        
        // Test each category to see if it has available cards
        const availableCategories = [];
        
        Object.entries(allCategories).forEach(([key, categoryInfo]) => {
            // Skip categories that don't apply to this mode
            if (mode === 'cashback' && key === 'rent') return; // Rent only available for travel mode
            if (mode === 'cashback' && (key === 'wholesale-clubs' || key === 'amazon')) {
                // Include these for cashback
            } else if (mode === 'travel' && (key === 'wholesale-clubs' || key === 'amazon')) {
                return; // Skip these for travel mode
            }
            
            // Test if this category has any cards
            const testFilter = { ...mergedBase, earning_any: [key] };
            const cardsWithCategory = applyFiltersTo(allCards, testFilter);
            
            if (cardsWithCategory.length > 0) {
                availableCategories.push(categoryInfo);
            }
        });
        
        return availableCategories;
    }

    function getAvailableAirlineHotelOptions(focus) {
        console.log(`✈️ getAvailableAirlineHotelOptions called for focus: ${focus}`);
        
        // Define all possible airline and hotel options with their labels and values
        const allAirlines = {
            'delta': { label: 'Delta', value: 'delta' },
            'united': { label: 'United', value: 'united' },
            'american': { label: 'American', value: 'american' },
            'southwest': { label: 'Southwest', value: 'southwest' },
            'jetblue': { label: 'JetBlue', value: 'jetblue' },
            'alaska': { label: 'Alaska', value: 'alaska' }
        };
        
        const allHotels = {
            'marriott': { label: 'Marriott', value: 'marriott' },
            'hilton': { label: 'Hilton', value: 'hilton' },
            'hyatt': { label: 'Hyatt', value: 'hyatt' },
            'ihg': { label: 'IHG', value: 'ihg' },
            'wyndham': { label: 'Wyndham', value: 'wyndham' },
            'choice': { label: 'Choice', value: 'choice' }
        };
        
        // Get the base filter for travel mode
        const baseFilter = { type: ['travel'] };
        
        // Get current filters (without airline-hotel to test each option)
        const testFilters = { ...state.travelFilters };
        delete testFilters['airline-hotel']; // Remove airline-hotel filter to test each one
        
        const mergedBase = mergeFilters(baseFilter, testFilters);
        
        // Test each option to see if it has available cards
        const availableOptions = [];
        
        // Determine which options to test based on focus
        let optionsToTest = {};
        if (focus === 'airline') {
            optionsToTest = allAirlines;
        } else if (focus === 'hotel') {
            optionsToTest = allHotels;
        } else {
            // Fallback to all options (shouldn't happen with current flow but keeps it robust)
            optionsToTest = { ...allAirlines, ...allHotels };
        }
        
        Object.entries(optionsToTest).forEach(([key, optionInfo]) => {
            // Test if this airline/hotel has any cards
            const testFilter = { ...mergedBase, 'airline-hotel': [key] };
            const cardsWithOption = applyFiltersTo(allCards, testFilter);
            
            console.log(`🔍 Testing ${focus} "${key}": ${cardsWithOption.length} cards available`);
            console.log(`   Test filter:`, testFilter);
            if (cardsWithOption.length > 0) {
                console.log(`   ✅ Adding ${focus} "${key}" to available options`);
                availableOptions.push(optionInfo);
            } else {
                console.log(`   ❌ Skipping ${focus} "${key}" - no cards available`);
            }
        });
        
        console.log(`🎯 Returning ${availableOptions.length} available ${focus} options:`, availableOptions);
        return availableOptions;
    }

    function getCurrentFilteredCards() {
        if (!state.mode) return allCards;
        
        if (state.mode === 'either') {
            const cashFilters = mergeFilters({ type: ['cashback'] }, state.cashbackFilters);
            const travFilters = mergeFilters({ type: ['travel'] }, state.travelFilters);
            return state.activeTab === 'cashback' ? applyFiltersTo(allCards, cashFilters) : applyFiltersTo(allCards, travFilters);
        }
        
        const base = {};
        if (state.mode === 'cashback') base.type = ['cashback'];
        if (state.mode === 'travel') base.type = ['travel'];
        const merged = mergeFilters(base, state.mode === 'travel' ? state.travelFilters : state.cashbackFilters);
        return applyFiltersTo(allCards, merged);
    }

    function updateMobileScrollIndicator(cards) {
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        const mobileCount = document.getElementById('mobile-scroll-count');

        if (!mobileIndicator || !mobileCount) return;

        // Hide during completion step
        if (isCompletionStep()) {
            mobileIndicator.style.display = 'none';
            return;
        }

        // Only show on mobile and when there are cards to show
        if (window.innerWidth <= 768 && cards.length > 0) {
            mobileIndicator.style.display = 'block';
            mobileCount.textContent = cards.length + ' Cards';
        } else {
            mobileIndicator.style.display = 'none';
        }
    }

    function updateDesktopCardCount(cards) {
        const desktopIndicator = document.getElementById('desktop-card-count');
        const desktopCount = document.getElementById('desktop-card-count-number');

        if (!desktopIndicator || !desktopCount) return;

        // Hide during completion step
        if (isCompletionStep()) {
            desktopIndicator.style.display = 'none';
            return;
        }

        // Only show on desktop and when there are cards to show, and when a mode is selected
        if (window.innerWidth > 768 && cards.length > 0 && state.mode) {
            desktopIndicator.style.display = 'block';
            desktopCount.textContent = cards.length + ' Cards';
        } else {
            desktopIndicator.style.display = 'none';
        }
    }

    function bindHelpBoxToggle() {
        const helpBox = document.getElementById('help-box');
        const helpTitle = helpBox.querySelector('.help-title');
        const helpText = helpBox.querySelector('.help-text');
        
        // Check if content height exceeds threshold - make it collapse more aggressively like mobile
        function shouldCollapse() {
            if (!helpText) return false;
            const contentHeight = helpText.scrollHeight;
            return contentHeight > 100; // Much lower threshold to match mobile behavior
        }
        
        // Add collapsible behavior on both mobile and desktop
        function checkMobileAndSetup() {
            helpBox.classList.add('collapsible');
            
            // Start collapsed to show text with fade effect like mobile
            helpBox.classList.add('collapsed');
            
            // Remove any existing click listeners to avoid duplicates
            const newHelpTitle = helpBox.querySelector('.help-title');
            const newHelpText = helpBox.querySelector('.help-text');
            
            function handleToggle() {
                helpBox.classList.toggle('expanded');
                helpBox.classList.toggle('collapsed');
                // Update cursor based on state
                const isCollapsed = helpBox.classList.contains('collapsed');
                newHelpText.style.cursor = isCollapsed ? 'pointer' : 'default';
                helpBox.style.cursor = isCollapsed ? 'pointer' : 'default';
            }
            
            newHelpTitle.removeEventListener('click', handleToggle);
            newHelpTitle.addEventListener('click', handleToggle);
            
            // Also make the collapsed text area clickable (for the bottom arrow)
            newHelpText.removeEventListener('click', handleToggle);
            newHelpText.addEventListener('click', handleToggle);

            // As a safety net on mobile Safari, toggle when tapping anywhere in the help box
            function containerToggle(e) {
                // Don't toggle when tapping links inside the advice text
                const isLink = e.target.closest && e.target.closest('a');
                if (isLink) return;
                // Only toggle when currently collapsed to prevent accidental collapses when expanded
                if (helpBox.classList.contains('collapsed')) {
                    handleToggle();
                }
            }
            helpBox.removeEventListener('click', containerToggle);
            helpBox.addEventListener('click', containerToggle);
            
            // Set initial cursor based on collapsed state
            const isInitiallyCollapsed = helpBox.classList.contains('collapsed');
            newHelpText.style.cursor = isInitiallyCollapsed ? 'pointer' : 'default';
            helpBox.style.cursor = isInitiallyCollapsed ? 'pointer' : 'default';
        }
        
        // Setup on load
        checkMobileAndSetup();
        
        // Re-setup on resize
        window.addEventListener('resize', checkMobileAndSetup);
        
        // Also update mobile scroll indicator on resize
        window.addEventListener('resize', () => {
            if (state.mode && allCards.length > 0) {
                const currentCards = getCurrentFilteredCards();
                updateMobileScrollIndicator(currentCards);
                updateDesktopCardCount(currentCards);
            }
        });
    }

    function initCoach() {
        // Clear all filter states to ensure no pre-selections
        clearAllFilterStates();
        
        buildSteps();
        bindWizardControls();
        bindHelpBoxToggle();
        renderStep();
        recomputeAndRender();
    }
    
    function clearAllFilterStates() {
        // Reset all filter states to empty
        state.cashbackFilters = {
            earning_any: [],
            protections: []
        };
        state.travelFilters = {
            'airline-hotel': [],
            earning_any: [],
            protections: []
        };
        state.lastApplied = null;
    }

    function buildSteps() {
        state.steps = [
            {
                id: 'goal',
                title: 'What’s your goal right now?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>I want to earn cash back</strong></div>', value: 'cashback' },
                    { label: '<div class="text-content"><strong>I want to earn travel rewards</strong></div>', value: 'travel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'not-sure' }
                ],
                help: 'If you are new or undecided, start with Cash Back. It is simple, real money, and a great baseline.<br><br>If you\'re experienced, or okay putting in some additional work, you can get more value out of travel cards. Know your own personality, because it is more work.<br><br>If you really have no idea, we\'d recommend learning more about each option <a href="learning.html" style="color: #059669; text-decoration: underline;">here</a> and coming back.',
                onAnswer: (val) => { 
                    state.mode = val; 
                    // Always jump to the first branch step upon selecting a goal
                    state.stepIndex = 1; 
                    state.lastApplied = null; 
                    configureModeTabs();
                    recomputeAndRender();
                    // Render the next step immediately for all choices
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Not sure flow - Question 1: Do you travel?
            {
                id: 'ns1', branch: 'not-sure',
                title: 'Do you ever travel?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                onAnswer: (val) => {
                    state.notSureAnswers = state.notSureAnswers || {};
                    state.notSureAnswers.travels = val === 'yes';
                    if (val === 'no') {
                        // Route directly to cash-back flow
                        state.mode = 'cashback';
                        configureModeTabs();
                        state.stepIndex = 0; // Set after configureModeTabs to override its default
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                    }
                    // If yes, continue to next question (step will auto-advance)
                }
            },
            // Not sure flow - Question 2: How hands-on?
            {
                id: 'ns2', branch: 'not-sure',
                title: 'How hands-on do you want to be?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Lower maintenance</strong></div>', value: 'low' },
                    { label: '<div class="text-content"><strong>I\'ll put in the work</strong></div>', value: 'high' }
                ],
                help: 'This is a personality call. If you like simple routines and hate fine print, go <strong>"Lower maintenance"</strong>. If you enjoy tinkering and don\'t mind a few extra steps for more upside, pick <strong>"I\'ll put in the work"</strong>. There\'s no right answer—choose the one that matches your personality.',
                onAnswer: (val) => {
                    state.notSureAnswers = state.notSureAnswers || {};
                    state.notSureAnswers.handsOn = val === 'high';
                    
                    if (val === 'low') {
                        // Route to cash-back flow (fewer rules, steady results)
                        state.mode = 'cashback';
                        configureModeTabs();
                        state.stepIndex = 0; // Set after configureModeTabs to override its default
                    } else {
                        // Route to travel flow (more moving parts, higher upside)
                        state.mode = 'travel';
                        configureModeTabs(); // This sets stepIndex = 1, which goes to tr2
                        state.stepIndex = 0; // Override to 0 to start with tr1 (international travel question)
                    }
                    
                    recomputeAndRender();
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Travel mini-quiz Q0: First travel card?
            {
                id: 'tmq0', branch: 'travel-mini-quiz',
                title: 'Would this be your first travel card?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'If you\'ve never opened a card mainly for flights, hotels, or travel perks, pick Yes. Everyday cash-back cards don\'t count here.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.firstTravelCard = val === 'yes';
                    
                    if (val === 'yes') {
                        // Route to Flexible points path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['flex'];
                        configureModeTabs();
                        state.stepIndex = 2; // Skip tr1 (international) and tr2 (focus), go to next step
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    // If no, continue to next question
                }
            },
            // Travel mini-quiz Q1: Same airline?
            {
                id: 'tmq1', branch: 'travel-mini-quiz',
                title: 'Do you mostly fly the same airline?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes, mostly one</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No, I mix it up</strong></div>', value: 'no' }
                ],
                help: 'Think about last year (or next). If you usually start with one airline—or fly it more often than not—that\'s a Yes.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.airlineLoyal = val === 'yes';
                    // Continue to next question
                }
            },
            // Travel mini-quiz Q2: Same hotel chain?
            {
                id: 'tmq2', branch: 'travel-mini-quiz',
                title: 'Do you mostly stay with one hotel chain?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes, mostly one</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No, I mix it up</strong></div>', value: 'no' }
                ],
                help: 'If you find yourself booking the same hotel chain on most trips, that\'s a Yes. If you chase price or location across different hotels, pick No.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.hotelLoyal = val === 'yes';
                    
                    const airlineLoyal = state.travelMiniQuizAnswers.airlineLoyal;
                    const hotelLoyal = val === 'yes';
                    
                    // Route based on loyalty combinations
                    if (!airlineLoyal && !hotelLoyal) {
                        // Flexible points path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['flex'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    } else if (airlineLoyal && !hotelLoyal) {
                        // Airline path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['airline'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    } else if (!airlineLoyal && hotelLoyal) {
                        // Hotel path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['hotel'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    // If both are loyal, continue to Q3
                }
            },
            // Travel mini-quiz Q3: What sounds nicer?
            {
                id: 'tmq3', branch: 'travel-mini-quiz',
                title: 'What sounds nicer this year?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Free checked bags & earlier boarding</strong></div>', value: 'airline' },
                    { label: '<div class="text-content"><strong>A free hotel night & status perks</strong></div>', value: 'hotel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'not-sure' }
                ],
                help: 'Go with what sounds better for your trips this year. If it\'s a toss-up, Not sure is honest.',
                onAnswer: (val) => {
                    state.mode = 'travel';
                    
                    if (val === 'airline') {
                        state.travelFilters.focus = ['airline'];
                    } else if (val === 'hotel') {
                        state.travelFilters.focus = ['hotel'];
                    } else {
                        // Not sure -> Flexible points
                        state.travelFilters.focus = ['flex'];
                    }
                    
                    configureModeTabs();
                    state.stepIndex = 2;
                    recomputeAndRender();
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Cashback path
            {
                id: 'cb1', branch: 'cashback',
                title: 'Do you already have a Flat Rate Card?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'A <strong>Flat Rate Card</strong> earns the same cash back on almost every purchase. No categories to track. Simple and predictable. These cards typically offer 1.5%–2% everywhere—much better than the standard 1%. If you only want one card, this is the easy choice. Swipe and move on.\n\nIf you want to optimize your setup, start with a Flat Rate Card as your default. Use category cards when they beat your flat rate. The Flat Rate Card quietly covers everything else.\n\nEither way—simple or optimized—a <strong>Flat Rate Card</strong> is your practical starting point.',
                onAnswer: (val) => {
                    // Store the user's answer for step visibility logic
                    state.cashbackFilters.hasFlatRate = val === 'yes';
                    console.log(`🔍 Set hasFlatRate to:`, state.cashbackFilters.hasFlatRate, 'for answer:', val);
                    
                    const arr = state.cashbackFilters['earning_any'] || [];
                    if (val === 'no') {
                        // They don't have flat-rate, show them flat-rate cards
                        if (!arr.includes('flat-rate')) arr.push('flat-rate');
                        state.lastApplied = { key: 'earning_any', value: 'flat-rate' };
                    } else {
                        // They already have flat-rate, focus on categories instead
                        state.cashbackFilters['earning_any'] = arr.filter(v => v !== 'flat-rate');
                        state.lastApplied = { key: 'earning_any', value: 'flat-rate' };
                    }
                    state.cashbackFilters['earning_any'] = Array.from(new Set(state.cashbackFilters['earning_any'] || arr));
                }
            },
            {
                id: 'cb2', branch: 'cashback',
                title: 'Where do you want more cash back?',
                tip: 'Pick your <strong>top priority</strong> category where you want the most cash back.',
                type: 'radio',
                get options() {
                    return getAvailableEarningCategories('cashback');
                },
                help: 'Once you\'ve got a <strong>Flat Rate Card</strong> baseline, add cards that pay higher rates where you actually spend. Pick 1–2 to start; your Flat Rate Card covers the rest.\n\nCategory rules vary by card. We\'ll flag common quirks (exclusions, caps, portal-only rates) so there are no surprises.\n\n• <strong>Dining & bars</strong> — restaurants, fast food, delivery apps, coffee shops\n• <strong>Groceries</strong> — supermarkets; big-box/warehouse stores (Walmart, Target, Costco, Sam\'s Club) usually don\'t count as groceries.\n• <strong>Gas / EV charging</strong> — gas stations and many public chargers.\n• <strong>Travel</strong> — flights, hotels, and other travel. Terms vary by card—some require booking through the issuer\'s portal; others count direct bookings. Check the card\'s details.\n• <strong>Transit / rideshare</strong> — subways, buses, trains, parking, tolls, Uber/Lyft.\n• <strong>Drugstores</strong> — Walgreens, CVS, and many independents.\n• <strong>Entertainment</strong> — tickets for movies, concerts, sports, museums, zoos.\n• <strong>Wholesale clubs</strong> — Costco, Sam\'s Club (codes differently than groceries).\n• <strong>Amazon</strong> — The Amazon Credit card is amazing if you shop on Amazon. 5% back on everything!\n\nNot sure what to pick? Go with the categories you hit every month. Your Flat Rate Card backs up everything else.',
                onAnswer: (val) => {
                    // Set single category selection (radio behavior)
                    state.cashbackFilters['earning_any'] = [val];
                    state.lastApplied = { key: 'earning_any', value: val };
                }
            },
            {
                id: 'cb3', branch: 'cashback',
                title: 'What protections matter to you?',
                tip: 'Pick your most important protection to find cards that offer it.',
                type: 'radio',
                get options() {
                    return getAvailableProtections('cashback');
                },
                help: 'Protections aren\'t as exciting as rewards, but they can save real money when something goes wrong.\n\n<strong>Phone protection</strong>\nPay your monthly cell phone bill with the card; if a covered phone is accidentally damaged or stolen, you can file a claim. It applies to every line on that bill, so one card can cover multiple phones. This can let you drop paid phone insurance like AppleCare+ or carrier add-ons.\n\n<strong>Purchase protection & extended warranty</strong>\nPay with the card, keep your receipt, and if an eligible item is damaged, stolen, or fails within the covered window, you can file a claim. Terms, caps, and exclusions vary by card.',
                onAnswer: (val) => { 
                    if (val === 'skip-protections') {
                        console.log(`🛡️ Cashback protections skipped`);
                        // Don't set any protections filter, just skip
                        state.lastApplied = { key: 'skip-protections', value: true };
                        return;
                    }
                    
                    console.log(`🛡️ Cashback protection selected: ${val}`);
                    state.cashbackFilters.protections = [val];
                    state.lastApplied = { key: 'protections', value: val };
                    console.log(`📝 Updated cashbackFilters:`, state.cashbackFilters);
                }
            },
            // Travel path - International question first
            {
                id: 'tr1', branch: 'travel',
                title: 'Do you travel outside the U.S. at least once a year?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'If you go abroad even once a year, a <strong>no foreign transaction fee</strong> card is an easy win—about <strong>3%</strong> saved on every purchase (including online charges in foreign currency). That\'s $30 for every $1000 that you spend.',
                onAnswer: (val) => {
                    const arr = new Set(state.travelFilters.perks || []);
                    if (val === 'yes') { arr.add('no-foreign-fees'); state.lastApplied = { key: 'perks', value: 'no-foreign-fees' }; }
                    else { arr.delete('no-foreign-fees'); state.lastApplied = { key: 'perks', value: 'no-foreign-fees' }; }
                    state.travelFilters.perks = Array.from(arr);
                }
            },
            {
                id: 'tr2', branch: 'travel',
                title: 'What do you want most right now?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Flexible Points</strong></div>', value: 'flex' },
                    { label: '<div class="text-content"><strong>Airline Perks</strong></div>', value: 'airline' },
                    { label: '<div class="text-content"><strong>Hotel Perks</strong></div>', value: 'hotel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'none' }
                ],
                help: 'If you\'re just getting started, go with <strong>flexible points</strong> (also called bank points). This is what people mean by "Amex points" or "Capital One Miles." You earn on everyday spending, then use them to book on any airline or hotels.\n\n<strong>Airline and hotel cards</strong> are different. You\'re earning rewards tied to one specific airline or hotel chain, and the value shows up as that airline\'s or hotel\'s perks—think a free night or a checked-bag benefit.\n\nFlexible points cards usually earn more on everyday spend, while airline or hotel cards are mostly about perks—so lean flexible unless your loyalty to a specific airline or hotel chain makes those extras a clear win.',
                onAnswer: (val) => {
                    if (val === 'none') {
                        // Redirect to travel mini-quiz
                        state.mode = 'travel-mini-quiz';
                        state.stepIndex = 1; // Go to first travel mini-quiz question (tmq0)
                        configureModeTabs();
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    state.travelFilters.focus = [val];
                    // Do not hard filter issuer; only controls visibility of airline/hotel step
                }
            },
            {
                id: 'tr2b', branch: 'travel',
                title: 'Do you need airport lounge access?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Must Have</strong></div>', value: 'must' },
                    { label: '<div class="text-content"><strong>Nice To Have</strong></div>', value: 'nice' }
                ],
                help: 'Lounge access usually comes with the most premium cards. Choose <strong>Must-have</strong> only if it\'s a dealbreaker—otherwise pick <strong>Nice to have</strong> to keep more options open.',
                onAnswer: (val) => {
                    if (val === 'must') { 
                        // When lounge access is Must Have, ONLY filter for lounge access
                        state.travelFilters.perks = ['lounge-access'];
                        state.lastApplied = { key: 'perks', value: 'lounge-access' }; 
                    } else if (val === 'nice') { 
                        // When nice to have, remove lounge-access but keep other perks
                        const arr = new Set(state.travelFilters.perks || []);
                        arr.delete('lounge-access'); 
                        state.travelFilters.perks = Array.from(arr);
                        state.lastApplied = { key: 'perks', value: 'lounge-access' }; 
                    }
                }
            },
            {
                id: 'tr3', branch: 'travel',
                get title() {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    if (focus === 'airline') {
                        return 'Which airline are you loyal to?';
                    } else if (focus === 'hotel') {
                        return 'Which hotel chain are you loyal to?';
                    } else {
                        return 'Which airline or hotel are you loyal to?';
                    }
                },
                type: 'checkbox',
                getOptions: () => {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return getAvailableAirlineHotelOptions(focus);
                },
                get help() {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    if (focus === 'airline') {
                        return 'Choose the airline you fly most often or have status with. Think about which airline you\'d book first when prices are similar, or where you have the most miles. If you truly mix it up with no preference, go back and choose flexible points instead.';
                    } else if (focus === 'hotel') {
                        return 'Choose the hotel chain you stay at most often or have status with. Think about which hotel you\'d book first when prices are similar, or where you have the most points. If you truly mix it up with no preference, go back and choose flexible points instead.';
                    } else {
                        return 'Choose the airline or hotel chain you\'re most loyal to. Think about which one you\'d book first when prices are similar, or where you have status or the most points. If you truly mix it up with no preference, go back and choose flexible points instead.';
                    }
                },
                onAnswer: (vals) => { 
                    state.travelFilters['airline-hotel'] = vals;
                    
                    // Auto-advance after a short delay like radio buttons do
                    setTimeout(() => {
                        const currentCards = getCurrentFilteredCards();
                        console.log(`🔍 Auto-advance check for tr3: ${currentCards.length} cards available`);
                        
                        // Check for single-card completion first
                        if (currentCards.length === 1) {
                            console.log('🎯 Found exactly one card from tr3 - auto-advancing to completion');
                            const steps = visibleSteps();
                            const completionStepIndex = steps.findIndex(s => s.id === 'completion');
                            if (completionStepIndex !== -1) {
                                state.stepIndex = completionStepIndex;
                                renderStep();
                                recomputeAndRender();
                                return;
                            }
                        }
                        
                        // Normal auto-advance to next step
                        const steps = visibleSteps();
                        console.log(`📊 Step tr3: current index ${state.stepIndex}, total steps ${steps.length}`);
                        
                        if (state.stepIndex < steps.length - 1) {
                            // Auto-advance regardless of card count for airline/hotel selection
                            console.log(`✅ Auto-advancing from tr3 to next step`);
                            state.stepIndex += 1;
                            renderStep();
                            recomputeAndRender(); // Re-render cards when auto-advancing
                        }
                    }, 300);
                }
            },
            {
                id: 'tr4', branch: 'travel',
                title: 'Where do you want more rewards?',
                tip: 'Pick your <strong>top priority</strong> category where you want the most rewards.',
                type: 'radio',
                get options() {
                    return getAvailableEarningCategories('travel');
                },
                help: 'Trips start here. Want simple? Go flat-rate and stop thinking about it. Big on dining or groceries? Grab a food card and let dinner pay for flights. You know your spend—pick what actually matters to you.\n\n• <strong>Flat Rate</strong> — The glue. Works everywhere and you don\'t have to think.\n• <strong>Rent</strong> — Only one card offers points on rent, it\'s a pretty sweet setup.\n• <strong>Dining & bars</strong> — restaurants, fast food, delivery apps, coffee shops\n• <strong>Groceries</strong> — supermarkets; big-box/warehouse stores (Walmart, Target, Costco, Sam\'s Club) usually don\'t count as groceries.\n• <strong>Gas / EV charging</strong> — gas stations and many public chargers.\n• <strong>Travel</strong> — flights, hotels, and other travel. Terms vary by card—some require booking through the issuer\'s portal; others count direct bookings. Check the card\'s details.\n• <strong>Transit / rideshare</strong> — subways, buses, trains, parking, tolls, Uber/Lyft.\n• <strong>Drugstores</strong> — Walgreens, CVS, and many independents.\n• <strong>Entertainment</strong> — tickets for movies, concerts, sports, museums, zoos.',
                onAnswer: (val) => {
                    // Set single category selection (radio behavior)
                    state.travelFilters['earning_any'] = [val];
                    state.lastApplied = { key: 'earning_any', value: val };
                }
            },
            {
                id: 'tr5', branch: 'travel',
                title: 'What travel protections matter to you?',
                tip: 'Pick your most important protection to find cards that offer it.',
                type: 'radio',
                get options() {
                    return getAvailableProtections('travel');
                },
                help: 'Travel protections aren\'t as exciting as rewards, but they can save real money when something goes wrong.\n\n<strong>Trip delay & cancellation</strong>\nIf your trip is delayed or cancelled due to covered reasons (weather, mechanical issues, etc.), you can file a claim for expenses like meals, hotels, and transportation. Coverage amounts and time thresholds vary by card.\n\n<strong>Rental car CDW (Collision Damage Waiver)</strong>\nPrimary CDW is best—it covers damage without involving your personal auto insurance. Secondary CDW only kicks in after your personal insurance. Always decline the rental company\'s expensive coverage when you have primary CDW.\n\n<strong>Lost/Delayed baggage</strong>\nIf your checked bags are lost, stolen, or delayed, you can file a claim for essential items and replacement costs. Coverage amounts and time requirements vary by card.',
                onAnswer: (val) => { 
                    if (val === 'skip-protections') {
                        console.log(`🛡️ Travel protections skipped`);
                        // Don't set any protections filter, just skip
                        state.lastApplied = { key: 'skip-protections', value: true };
                        return;
                    }
                    
                    console.log(`🛡️ Travel protection selected: ${val}`);
                    state.travelFilters.protections = [val];
                    state.lastApplied = { key: 'protections', value: val };
                    console.log(`📝 Updated travelFilters:`, state.travelFilters);
                }
            },
            // Completion step - shows for all branches
            {
                id: 'completion',
                title: 'Congratulations!',
                type: 'completion',
                branch: 'all'
            }
        ];
    }

    function visibleSteps() {
        let steps = state.steps.filter(s => {
            if (!s.branch) return true;
            if (s.id === 'completion') {
                // Show completion step when we're on or past the last regular step
                const regularSteps = state.steps.filter(step => {
                    if (!step.branch) return true;
                    if (state.mode === 'travel') {
                        if (step.id === 'tr2b') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus === 'flex' || focus === 'airline';
                        }
                        if (step.id === 'tr3') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus === 'airline' || focus === 'hotel';
                        }
                        if (step.id === 'tr4') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus !== 'airline' && focus !== 'hotel';
                        }
                        return step.branch === 'travel';
                    }
                    if (state.mode === 'cashback') {
                        if (step.id === 'cb2' && state.cashbackFilters.hasFlatRate === false) {
                            return false;
                        }
                        return step.branch === 'cashback';
                    }
                    if (state.mode === 'not-sure') {
                        return step.branch === 'not-sure';
                    }
                    if (state.mode === 'travel-mini-quiz') {
                        return step.branch === 'travel-mini-quiz';
                    }
                    return false;
                });
                return state.stepIndex >= regularSteps.length - 1;
            }
            if (state.mode === 'travel') {
                if (s.id === 'tr2b') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus === 'flex' || focus === 'airline';
                }
                if (s.id === 'tr3') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus === 'airline' || focus === 'hotel';
                }
                if (s.id === 'tr4') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus !== 'airline' && focus !== 'hotel';
                }
                return s.branch === 'travel';
            }
            if (state.mode === 'cashback') {
                // Skip categories step (cb2) if they don't have a flat-rate card (answered 'no' to cb1)
                if (s.id === 'cb2' && state.cashbackFilters.hasFlatRate === false) {
                    return false;
                }
                return s.branch === 'cashback';
            }
            if (state.mode === 'not-sure') {
                return s.branch === 'not-sure';
            }
            if (state.mode === 'travel-mini-quiz') {
                return s.branch === 'travel-mini-quiz';
            }
            return false;
        });
        
        // Inject dynamic follow-up category steps
        const dynamicSteps = [];
        
        // For cashback mode, inject follow-up after cb2 if there are multiple cards
        if (state.mode === 'cashback' && state.cashbackFilters.earning_any && state.cashbackFilters.earning_any.length > 0) {
            const selectedCategory = state.cashbackFilters.earning_any[0]; // First selected category
            const followUpStep = generateFollowUpCategoryStep('cashback', 'cb2b', selectedCategory);
            if (followUpStep) {
                // Insert after cb2
                const cb2Index = steps.findIndex(s => s.id === 'cb2');
                if (cb2Index !== -1) {
                    dynamicSteps.push({ step: followUpStep, insertAfter: cb2Index });
                }
            }
        }
        
        // For travel mode, inject follow-up after tr4 if there are multiple cards
        if (state.mode === 'travel' && state.travelFilters.earning_any && state.travelFilters.earning_any.length > 0) {
            const selectedCategory = state.travelFilters.earning_any[0]; // First selected category
            const followUpStep = generateFollowUpCategoryStep('travel', 'tr4b', selectedCategory);
            if (followUpStep) {
                // Insert after tr4
                const tr4Index = steps.findIndex(s => s.id === 'tr4');
                if (tr4Index !== -1) {
                    dynamicSteps.push({ step: followUpStep, insertAfter: tr4Index });
                }
            }
        }
        
        // Insert dynamic steps in reverse order to maintain correct indices
        dynamicSteps.reverse().forEach(({ step, insertAfter }) => {
            steps.splice(insertAfter + 1, 0, step);
        });
        
        return steps;
    }

    function clearFiltersFromFutureSteps(currentStepIndex) {
        const steps = visibleSteps();
        const currentMode = state.mode;
        
        // Determine which filter set to modify
        let targetFilters;
        if (currentMode === 'travel') {
            targetFilters = state.travelFilters;
        } else if (currentMode === 'cashback') {
            targetFilters = state.cashbackFilters;
        } else if (currentMode === 'travel-mini-quiz') {
            targetFilters = state.travelFilters;
        } else {
            // For 'either' mode, don't clear anything since they're still on goal step
            return;
        }
        
        // Clear filters from steps after the current one (not including current step)
        for (let i = currentStepIndex + 1; i < steps.length; i++) {
            const step = steps[i];
            const filterKey = stepToFilterKey(step.id);
            
            if (filterKey && targetFilters[filterKey]) {
                console.log(`Clearing filter ${filterKey} from step ${step.id}`);
                delete targetFilters[filterKey];
            }
        }
        
        // Clear lastApplied if it was from a future step
        state.lastApplied = null;
    }

    function bindWizardControls() {
        const backBtn = document.getElementById('back-btn');
        // Remove any existing listeners to prevent duplicates
        backBtn.replaceWith(backBtn.cloneNode(true));
        const newBackBtn = document.getElementById('back-btn');
        
        newBackBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            if (state.stepIndex > 0) {
                console.log('🔙 Going back from step', state.stepIndex, 'to', state.stepIndex - 1);
                
                // Go back one step first
                state.stepIndex--;

                // After moving back, clear any selection associated with the step we have returned to
                let steps = visibleSteps();
                const stepNow = steps[state.stepIndex];
                if (stepNow) {
                    const currentFilterKey = stepToFilterKey(stepNow.id);
                    if (currentFilterKey) {
                        let targetFilters = state.mode === 'travel' ? state.travelFilters : state.cashbackFilters;
                        if (targetFilters && targetFilters[currentFilterKey]) {
                            console.log('🔙 Clearing current step filter', currentFilterKey, 'for step', stepNow.id);
                            delete targetFilters[currentFilterKey];
                        }
                    }
                }

                // Also clear any filters from steps after the current one to keep state consistent
                clearFiltersFromFutureSteps(state.stepIndex);
                
                // If going back to the goal step, reset everything
                if (state.stepIndex === 0) {
                    state.mode = null;
                    state.travelFilters = {};
                    state.cashbackFilters = {};
                    state.activeTab = null;
                    configureModeTabs();
                }
                
                // Force complete reset of card display
                currentCards = [];
                const cardsGrid = document.getElementById('cards-grid');
                if (cardsGrid) {
                    cardsGrid.innerHTML = '';
                }
                
                renderStep();
                recomputeAndRender();
            }
        });
        // Next button removed - everything auto-advances
        document.getElementById('mode-tabs').addEventListener('click', (e) => {
            const btn = e.target.closest('.tab'); if (!btn) return;
            document.querySelectorAll('#mode-tabs .tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            state.activeTab = btn.dataset.tab;
            recomputeAndRender();
        });
    }

    function renderStep() {
        const steps = visibleSteps();
        const total = Math.max(steps.length, 1);
        // Ensure stepIndex is within bounds of visible steps
        const current = Math.min(Math.max(state.stepIndex, 0), total - 1);
        // Don't overwrite state.stepIndex here - it should only be changed by navigation actions
        const step = steps[current];
        
        console.log('🔍 renderStep - mode:', state.mode, 'stepIndex:', state.stepIndex, 'current:', current);
        console.log('🔍 visibleSteps:', steps.map(s => s.id));
        console.log('🔍 current step:', step ? step.id : 'none');
        const container = document.getElementById('steps-container');
        const bar = document.getElementById('progress-bar');

        if (!step) { 
            const questionEl = document.getElementById('wizard-question');
            questionEl.textContent = 'Step-by-step';
            questionEl.className = 'wizard-title';
            container.innerHTML = '<div style="color:#64748b;">All set. Adjust answers on the left anytime.</div>'; 
            bar.style.width = '100%'; 
            updateHelp(null); 
            return; 
        }

        // Handle completion step with celebration
        if (step.type === 'completion') {
            // Add completion styling to wizard
            const wizard = document.querySelector('.wizard');
            if (wizard) {
                wizard.classList.add('completion');
            }
            
            const questionEl = document.getElementById('wizard-question');
            questionEl.textContent = step.title;
            questionEl.className = 'wizard-title completion-title';
            
            // Dark progress bar for completion (high contrast on green background)
            bar.style.width = '100%';
            bar.style.backgroundColor = '#047857'; // Darker green for contrast
            bar.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
            bar.classList.add('celebration-bar');
            
            // Get current cards to customize message
            const currentCards = getCurrentFilteredCards();
            const cardCount = currentCards.length;
            
            // Customize message based on number of cards
            let message, subtitle;
            if (cardCount === 1) {
                message = "We found the most practical card for you!";
                subtitle = "This card matches all your preferences perfectly.";
            } else {
                message = "We've narrowed all the cards to ones that match you!";
                subtitle = "Your personalized recommendations are ready.";
            }
            
            // Celebration content
            container.innerHTML = `
                <div class="completion-content">
                    <div class="celebration-icon">✓</div>
                    <h2 class="completion-message">${message}</h2>
                    <p class="completion-subtitle">${subtitle}</p>
                </div>
            `;
            
            // Hide navigation buttons
            document.getElementById('next-btn').style.display = 'none';
            document.getElementById('back-btn').style.display = 'none';
            
            // Hide all card count indicators during completion
            const desktopIndicator = document.getElementById('desktop-card-count');
            const mobileIndicator = document.getElementById('mobile-scroll-indicator');
            
            if (desktopIndicator) {
                desktopIndicator.style.display = 'none';
            }
            if (mobileIndicator) {
                mobileIndicator.style.display = 'none';
            }
            
            updateHelp(null);
            
            // Re-render cards with completion styling and hide card count
            recomputeAndRender();
            
            // Force completion styling after a short delay to ensure it shows
            setTimeout(forceCompletionStyling, 100);
            return;
        } else {
            // Remove completion styling for non-completion steps
            const wizard = document.querySelector('.wizard');
            if (wizard) {
                wizard.classList.remove('completion');
            }
        }

        const idx = current; bar.style.width = ((idx / total) * 100) + '%';

        // Build options UI
        const selected = getCurrentAnswer(step.id);
        // Get options from either static array or dynamic function
        const options = step.getOptions ? step.getOptions() : step.options;
        console.log(`🎨 Rendering step ${step.id}:`);
        console.log(`   - Has getOptions function: ${!!step.getOptions}`);
        console.log(`   - Has static options: ${!!step.options}`);
        console.log(`   - Final options (${options ? options.length : 0}):`, options);
        let optionsHtml = '';
        if (step.type === 'radio') {
            optionsHtml = options.map(opt => {
                const isSelected = selected === opt.value;
                const checked = isSelected ? 'checked' : '';
                const activeClass = isSelected ? 'active' : '';
                return `<label class="option ${activeClass}"><input type="radio" name="${step.id}" value="${opt.value}" ${checked}/> ${opt.label}</label>`;
            }).join('');
        } else if (step.type === 'checkbox') {
            const selectedArr = Array.isArray(selected) ? selected : [];
            optionsHtml = options.map(opt => {
                const checked = selectedArr.includes(opt.value) ? 'checked' : '';
                return `<label class="option ${checked? 'active':''}"><input type="checkbox" name="${step.id}" value="${opt.value}" ${checked}/> ${opt.label}</label>`;
            }).join('');
        }

        // Apply grid layout for category steps that have many options
        const shouldUseGrid = (step.id === 'cb2' || step.id === 'cb2b' || step.id === 'tr3' || step.id === 'tr4' || step.id === 'tr4b');
        const optionsClass = shouldUseGrid ? 'options grid-layout' : 'options';
        
        // Put the question in the header and options in the container
        const questionEl = document.getElementById('wizard-question');
        questionEl.textContent = step.title;
        questionEl.className = 'wizard-title question';

        // Add tip if it exists
        const tipHtml = step.tip ? `<div class="step-tip">${step.tip}</div>` : '';
        container.innerHTML = `${tipHtml}<div class="${optionsClass}">${optionsHtml}</div>`;

        // Always clear all selections first, then apply current answer if it exists
        container.querySelectorAll('.option').forEach(option => {
            option.classList.remove('active');
            option.blur(); // Remove focus to prevent stuck visual states
            const input = option.querySelector('input');
            if (input) {
                input.checked = false;
                input.blur(); // Remove focus from input as well
            }
        });
        
        // Now apply the current answer if it exists and is valid
        if (selected && ((step.type === 'radio' && selected) || (step.type === 'checkbox' && Array.isArray(selected) && selected.length > 0))) {
            if (step.type === 'radio') {
                const option = container.querySelector(`input[value="${selected}"]`);
                if (option) {
                    option.checked = true;
                    option.closest('.option').classList.add('active');
                }
            } else if (step.type === 'checkbox') {
                selected.forEach(value => {
                    const option = container.querySelector(`input[value="${value}"]`);
                    if (option) {
                        option.checked = true;
                        option.closest('.option').classList.add('active');
                    }
                });
            }
        }

        updateHelp(step);

        // Show/hide Next button based on step type and position
        const nextBtn = document.getElementById('next-btn');
        const backBtn = document.getElementById('back-btn');
        const isLastStep = current >= steps.length - 1;
        const isFirstStep = current === 0;
        
        // Show/hide back button - hide on first step
        if (isFirstStep) {
            backBtn.style.display = 'none';
        } else {
            backBtn.style.display = 'inline-block';
        }
        
        // Always hide Next button - everything auto-advances
        nextBtn.style.display = 'none';

        // Wire inputs and make entire options clickable
        // Global processing state to prevent multiple simultaneous selections
        let globalProcessing = false;
        
        container.querySelectorAll('.option').forEach(option => {
            const input = option.querySelector('input');
            let touchStarted = false;

            // Handle selection logic
            const handleSelection = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                console.log(`🖱️ Option clicked: "${input.value}" on step ${step.id} (type: ${step.type})`);
                
                // Prevent double-tap issues with shorter, more reliable protection
                if (globalProcessing) return;
                globalProcessing = true;
                
                // Shorter delay to prevent rapid successive taps
                setTimeout(() => { globalProcessing = false; }, 50);

                if (step.type === 'radio') {
                    // Exclusive select
                    container.querySelectorAll('input').forEach(cb => cb.checked = false);
                    input.checked = true;
                    // Visual state
                    container.querySelectorAll('.option').forEach(l => l.classList.remove('active'));
                    option.classList.add('active');
                    // Apply answer and auto-advance (except for goal step)
                    console.log(`📝 Calling onAnswer for ${step.id} with value: "${input.value}"`);
                    step.onAnswer(input.value);
                    console.log(`🔄 Calling recomputeAndRender after onAnswer`);
                    recomputeAndRender();
                    
                    // Don't auto-advance for the goal step - it handles its own navigation
                    if (step.id !== 'goal') {
                        // Use shorter delay and ensure we're not in processing state
                        setTimeout(() => {
                            // Don't auto-advance if we're still processing something else
                            if (globalProcessing) return;
                            
                            const steps = visibleSteps();
                            console.log(`📊 Step ${step.id}: current index ${state.stepIndex}, total steps ${steps.length}`);
                            
                            // Allow advancing to completion step (steps.length - 1)
                            // Check if there are any cards available before auto-advancing
                            const currentCards = getCurrentFilteredCards();
                            console.log(`🔍 Auto-advance check for ${step.id}: ${currentCards.length} cards available`);
                            
                            // Check for single-card completion first
                            if (currentCards.length === 1) {
                                console.log('🎯 Found exactly one card from radio step - auto-advancing to completion');
                                const completionStepIndex = steps.findIndex(s => s.id === 'completion');
                                if (completionStepIndex !== -1) {
                                    state.stepIndex = completionStepIndex;
                                    renderStep();
                                    recomputeAndRender();
                                    return;
                                }
                            }
                            
                            if (state.stepIndex < steps.length - 1) {
                                // For protection steps, always advance even if no cards match current strict criteria
                                // The user has made their choice and should see results
                                const isProtectionStep = step.id === 'cb3' || step.id === 'tr5';
                                
                                if (currentCards.length === 0 && !isProtectionStep) {
                                    // Don't auto-advance if no cards match criteria (except for protection steps)
                                    console.log(`❌ Not auto-advancing ${step.id} - no cards available`);
                                    return;
                                }
                                
                                if (isProtectionStep && currentCards.length === 0) {
                                    console.log(`🛡️ Protection step ${step.id} auto-advancing despite 0 cards - will show filtered results`);
                                }
                                
                                console.log(`✅ Auto-advancing from ${step.id} to step ${state.stepIndex + 1}`);
                                state.stepIndex++;
                                renderStep();
                                recomputeAndRender(); // Re-render cards when auto-advancing
                            } else {
                                console.log(`🏁 At final step ${step.id} (index ${state.stepIndex}), not auto-advancing`);
                            }
                        }, 100);
                    }
                } else if (step.type === 'checkbox') {
                    // Toggle selection
                    input.checked = !input.checked;
                    // Visual state
                    option.classList.toggle('active', input.checked);
                    const vals = Array.from(container.querySelectorAll('input:checked')).map(cb => cb.value);
                    step.onAnswer(vals);
                    state.lastApplied = { key: stepToFilterKey(step.id), value: input.value };
                    recomputeAndRender();
                }
            };

            // Track touch movement to distinguish between tap and scroll
            let touchStartX = 0;
            let touchStartY = 0;
            let touchMoved = false;

            const handleTouchStart = (e) => {
                touchStarted = true;
                touchMoved = false;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            };

            const handleTouchMove = (e) => {
                if (!touchStarted) return;
                
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // If moved more than 10px, consider it a scroll gesture
                if (deltaX > 10 || deltaY > 10) {
                    touchMoved = true;
                }
            };

            const handleTouchEnd = (e) => {
                if (!touchStarted) return;
                
                // Only trigger selection if it was a tap (no movement)
                if (!touchMoved) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleSelection(e);
                }
                
                touchStarted = false;
                touchMoved = false;
            };

            // Add event listeners
            option.addEventListener('click', handleSelection);
            option.addEventListener('touchstart', handleTouchStart, { passive: true });
            option.addEventListener('touchmove', handleTouchMove, { passive: true });
            option.addEventListener('touchend', handleTouchEnd, { passive: false });
        });
    }

    function stepToFilterKey(stepId) {
        if (stepId.startsWith('cb')) return stepId === 'cb3' ? 'protections' : 'earning_any';
        if (stepId === 'tr2') return 'focus'; // This is the flexible/airline/hotel focus question
        if (stepId === 'tr2b') return 'perks'; // This is the lounge access question
            if (stepId === 'tr3') return 'airline-hotel'; // This is the airline/hotel selection
        if (stepId === 'tr4' || stepId === 'tr4b') return 'earning_any'; // Earning categories (including follow-up)
        if (stepId === 'tr5') return 'protections'; // This is the travel protections
        // Travel mini-quiz steps should clear the focus filter when going back
        if (stepId.startsWith('tmq')) return 'focus';
        return null;
    }

    function updateHelp(step) {
        const helpEl = document.getElementById('help-content');
        const box = document.getElementById('help-box');
        if (!helpEl || !box) return;
        
        // Hide the help box when no step
        if (!step) {
            box.style.display = 'none';
            return;
        }
        
        // Show the help box for all other steps
        box.style.display = 'block';
        
        if (!step.help) {
            helpEl.innerHTML = '<ul class="recommendation-list" style="margin: 0; padding: 0; list-style: none;"><li>Answering "Yes" doesn\'t mean we are going to start recommending you crazy cards, we are just tyring to get to know you!</li></ul>';
        } else {
            // For each step, show its helper
            // Split the help text by double line breaks and create proper paragraphs
            const paragraphs = step.help.split('\n\n');
            const htmlContent = paragraphs.map(para => {
                // Replace single line breaks with <br> tags for proper line breaks
                const formattedPara = para.replace(/\n/g, '<br>');
                return `<p style="margin: 0 0 1rem 0; color: #64748b; font-size: 0.9rem; line-height: 1.6;">${formattedPara}</p>`;
            }).join('');
            helpEl.innerHTML = `<div>${htmlContent}</div>`;
        }
        
        // Reset practical advice to collapsed state for both mobile and desktop
        if (box.classList.contains('collapsible')) {
            const helpText = box.querySelector('.help-text');
            if (helpText) {
                // Always start collapsed when moving to a new step
                box.classList.add('collapsed');
                box.classList.remove('expanded');
                helpText.style.cursor = 'pointer';
                box.style.cursor = 'pointer';
                
                // Ensure click handlers are attached
                const helpTitle = box.querySelector('.help-title');
                const handleToggle = () => {
                    box.classList.toggle('expanded');
                    box.classList.toggle('collapsed');
                    // Update cursor based on state
                    const isCollapsed = box.classList.contains('collapsed');
                    helpText.style.cursor = isCollapsed ? 'pointer' : 'default';
                    box.style.cursor = isCollapsed ? 'pointer' : 'default';
                };
                helpTitle.removeEventListener('click', handleToggle);
                helpTitle.addEventListener('click', handleToggle);
                helpText.removeEventListener('click', handleToggle);
                helpText.addEventListener('click', handleToggle);

                // Container-level handler so tapping the down-arrow overlay always expands
                function containerToggle(e) {
                    const isLink = e.target.closest && e.target.closest('a');
                    if (isLink) return;
                    if (box.classList.contains('collapsed')) {
                        handleToggle();
                    }
                }
                box.removeEventListener('click', containerToggle);
                box.addEventListener('click', containerToggle);
            }
        }
    }

    function getCurrentAnswer(stepId) {
        if (stepId === 'stage') return state.stage;
        if (stepId === 'goal') return state.mode;

        // Return current filter state for specific steps
        if (stepId === 'cb2') return state.cashbackFilters['earning_any'] ? state.cashbackFilters['earning_any'][0] : null;
        if (stepId === 'cb3') return state.cashbackFilters.protections ? state.cashbackFilters.protections[0] : null;
        if (stepId === 'tr2') return state.travelFilters.focus ? state.travelFilters.focus[0] : null;
        if (stepId === 'tr2b') return null; // Always reset - no pre-selection
        if (stepId === 'tr3') return state.travelFilters['airline-hotel'] || [];
        if (stepId === 'tr4') return state.travelFilters['earning_any'] ? state.travelFilters['earning_any'][0] : null;
        if (stepId === 'tr5') return state.travelFilters.protections ? state.travelFilters.protections[0] : null;

        // For cb1 (Do you already have a Flat Rate Card?), return null to ensure no pre-selection
        if (stepId === 'cb1') return null;

        // For other travel/cashback steps, derive from filters or return null
        if (stepId.startsWith('tr')) return null;
        if (stepId.startsWith('cb')) return null;
        return null;
    }

    function configureModeTabs() {
        const tabs = document.getElementById('mode-tabs');
        if (state.mode) { 
            tabs.style.display = 'none'; 
            state.activeTab = state.mode; 
            // When a goal is chosen, always start at the first step of that branch
            if (state.mode === 'travel-mini-quiz') {
                state.stepIndex = 0; // Start at tmq0 for travel mini-quiz
            } else {
                state.stepIndex = 1;
            }
        } else {
            // No mode selected (after reset)
            tabs.style.display = 'none';
            state.activeTab = null;
        }
    }

    function recomputeAndRender() {
        const total = allCards.length;
        let showCards = [];
        
        console.log('Recomputing with state:', state);

        // If no mode is selected (still in quiz), show intro text instead of cards
        if (!state.mode) {
            console.log('No mode selected, showing intro text');
            showIntroText();
            updateActiveFilterChipsUI({});
            updateResultsHeadlineForQuiz();
            return;
        }
        
        // If in travel mini-quiz, show all travel cards
        if (state.mode === 'travel-mini-quiz') {
            console.log('In travel mini-quiz, showing all travel cards');
            const travelCards = allCards.filter(card => {
                let cardType;
                if (Array.isArray(card.type)) {
                    cardType = card.type;
                } else if (typeof card.type === 'string' && card.type.trim().startsWith('[') && card.type.trim().endsWith(']')) {
                    try { cardType = JSON.parse(card.type); } catch(e) { cardType = [card.type]; }
                } else {
                    cardType = [card.type];
                }
                return cardType.includes('travel');
            });
            updateActiveFilterChipsUI({});
            updateResultsHeadline(travelCards.length, total);
            renderCards(travelCards);
            
            // Handle Next button for travel mini-quiz
            const steps = visibleSteps();
            const currentStep = steps[state.stepIndex];
            const nextBtn = document.getElementById('next-btn');
            // Next button always hidden - everything auto-advances
            return;
        }

        // Single mode
        const base = {};
        if (state.mode === 'cashback') base.type = ['cashback'];
        if (state.mode === 'travel') base.type = ['travel'];
        if (state.mode === 'not-sure') {
            // For not-sure mode, show all cards initially
            updateActiveFilterChipsUI({});
            updateResultsHeadline(allCards.length, total);
            renderCards(allCards);
            
            // Handle Next button for not-sure mode
            const steps = visibleSteps();
            const currentStep = steps[state.stepIndex];
            const nextBtn = document.getElementById('next-btn');
            // Next button always hidden - everything auto-advances
            return;
        }
        const merged = mergeFilters(base, state.mode === 'travel' ? state.travelFilters : state.cashbackFilters);
        const cards = applyFiltersTo(allCards, merged);
        console.log(`🔄 recomputeAndRender: ${cards.length} cards found with filters:`, merged);
        updateActiveFilterChipsUI(merged);
        updateResultsHeadline(cards.length, total);
        
        if (cards.length === 0) { 
            renderZeroState(); 
            // Hide Next button when no cards match
            const nextBtn = document.getElementById('next-btn');
            if (nextBtn) nextBtn.style.display = 'none';
        } else if (cards.length === 1) {
            // Auto-advance to completion step when we have exactly one card
            const steps = visibleSteps();
            const currentStep = steps[state.stepIndex];
            
            // Only auto-advance if we're not already on the completion step
            if (currentStep && currentStep.id !== 'completion') {
                console.log('🎯 Found exactly one card - auto-advancing to completion');
                
                // Jump to the completion step
                const completionStepIndex = steps.findIndex(s => s.id === 'completion');
                if (completionStepIndex !== -1) {
                    state.stepIndex = completionStepIndex;
                    renderStep();
                    
                    // Force completion styling by calling renderCardsImmediate directly
                    renderCardsImmediate(cards, true); // true = isCompletion
                    currentCards = [...cards];
                    
                    // Force completion styling after a short delay to ensure it shows
                    setTimeout(forceCompletionStyling, 100);
                    return;
                }
            }
            
            renderCards(cards);
        } else { 
            // Check if we're on completion step to apply proper styling
            const steps = visibleSteps();
            const currentStep = steps[state.stepIndex];
            const isCompletion = currentStep && currentStep.type === 'completion';
            
            if (isCompletion) {
                // Force completion styling when rendering from completion step
                renderCardsImmediate(cards, true);
                currentCards = [...cards];
                setTimeout(forceCompletionStyling, 100);
            } else {
                renderCards(cards);
                // Next button always hidden - everything auto-advances
            }
        }
    }

    function mergeFilters(a, b) {
        const out = JSON.parse(JSON.stringify(a || {}));
        Object.entries(b || {}).forEach(([k,v]) => { if (v && v.length) out[k] = Array.isArray(v) ? [...v] : [v]; });
        return out;
    }

    function updateActiveFilterChipsUI(filters) {
        const container = document.getElementById('active-filters-chips');
        const line = document.getElementById('active-filters-line');
        container.innerHTML = '';
        
        // Handle case where filters is null/undefined or empty
        if (!filters || Object.keys(filters).length === 0) { 
            line.style.display = 'none'; 
            return; 
        }
        
        const entries = Object.entries(filters).filter(([_,vals]) => vals && vals.length);
        if (entries.length === 0) { 
            line.style.display = 'none'; 
            return; 
        }
        
        line.style.display = 'flex';
        const nameMap = {
            type:{travel:'Travel',cashback:'Cash back'},
            issuer:{'amex':'American Express','chase':'Chase','capital-one':'Capital One','citi':'Citi','wells-fargo':'Wells Fargo','discover':'Discover'},
            perks:{'lounge-access':'Lounge Access','tsa-precheck':'TSA PreCheck','clear':'CLEAR','no-foreign-fees':'No Foreign Transaction Fees','free-checked-bags':'Free Checked Bags','priority-boarding':'Priority Boarding','annual-free-night':'Annual Free Night','automatic-elite-status':'Elite Status','rotating':'Rotating','flat-rate':'Flat Rate'},
            'airline-hotel':{'delta':'Delta','united':'United','american':'American','southwest':'Southwest','jetblue':'JetBlue','alaska':'Alaska','marriott':'Marriott','hilton':'Hilton','hyatt':'Hyatt','ihg':'IHG','wyndham':'Wyndham','choice':'Choice'},
            protections:{'trip-delay-cancellation':'Trip Protections','rental-car-insurance':'Rental Car Insurance','cell-phone-protection':'Cell Phone Protection','lost-delayed-baggage':'Lost/Delayed Baggage'},
            earning_any:{'flat-rate':'Flat Rate','dining':'Dining','groceries':'Groceries','gas':'Gas','transit':'Transit','travel':'Travel','hotels':'Hotels','flights':'Flights','drugstores':'Drugstores','online':'Online','streaming':'Streaming','telecom':'Telecom','entertainment':'Entertainment','amazon':'Amazon','gas|ev-charging':'Gas/EV Charging','rideshare|transit':'Rideshare/Transit','travel|hotels|airlines':'Travel','wholesale-clubs':'Wholesale Clubs'}
        };
        entries.forEach(([k,vals]) => {
            vals.forEach(v => {
                const chip = document.createElement('div');
                chip.className = 'meta-chip';
                chip.style.background = '#059669'; chip.style.color = 'white'; chip.style.borderRadius = '20px';
                chip.style.display = 'inline-flex'; chip.style.alignItems = 'center'; chip.style.gap = '.4rem';
                chip.innerHTML = `${(nameMap[k]&&nameMap[k][v])||v} <button style="all:unset; cursor:pointer; font-weight:700;">×</button>`;
                chip.querySelector('button').addEventListener('click', ()=>{ removeFilter(k, v); });
                container.appendChild(chip);
            });
        });
    }

    function removeFilter(key, value) {
        // Determine which filter set to modify based on current mode
        let target;
        if (state.mode === 'travel') {
            target = state.travelFilters;
        } else if (state.mode === 'cashback') {
            target = state.cashbackFilters;
        } else if (state.mode === 'either') {
            // For "either" mode, modify the active tab's filter set
            target = state.activeTab === 'cashback' ? state.cashbackFilters : state.travelFilters;
        } else {
            // If no mode is set, don't modify anything
            return;
        }
        
        if (!target[key]) return;
        target[key] = target[key].filter(v => v !== value);
        if (target[key].length === 0) delete target[key];
        
        // Update the visual state of the wizard step to reflect the change
        renderStep();
        recomputeAndRender();
    }

    function clearCurrentStepSelections() {
        // Get the current step to determine what to clear
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        if (!currentStep) return;
        
        // Get the filter key for this step
        const filterKey = stepToFilterKey(currentStep.id);
        if (!filterKey) return;
        
        // Determine which filter set to modify based on current mode
        let target;
        if (state.mode === 'travel') {
            target = state.travelFilters;
        } else if (state.mode === 'cashback') {
            target = state.cashbackFilters;
        } else if (state.mode === 'either') {
            target = state.activeTab === 'cashback' ? state.cashbackFilters : state.travelFilters;
        } else {
            return;
        }
        
        // Clear only this step's selections
        if (target[filterKey]) {
            delete target[filterKey];
        }
        
        // Clear lastApplied if it was from this step
        if (state.lastApplied && state.lastApplied.key === filterKey) {
            state.lastApplied = null;
        }
        
        // Update the visual state and results
        renderStep();
        recomputeAndRender();
    }

    function getContextualTip() {
        // Get the current step to provide relevant advice
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        if (!currentStep) return 'Start by selecting your preferences above to find cards that match your needs.';
        
        // Provide contextual tips based on step type and content
        switch (currentStep.id) {
            case 'cb2': // Cashback earning categories
                return 'For cash back, focus on 1-2 categories where you spend the most each month. Your flat-rate card will handle everything else at 2%.';
            
            case 'cb3': // Cashback protections
                return 'These protections can save hundreds of dollars when you need them. Phone protection alone often replaces paid insurance plans.';
            
            case 'tr4': // Travel earning categories  
                return 'Travel cards often earn 2-3x on dining and travel. Focus on categories you hit regularly—your travel card covers the rest at 1x.';
            
            case 'tr3': // Travel airlines/hotels
                return 'Airline and hotel cards are best when you\'re loyal to that specific airline or hotel chain. If you mix it up, flexible points are usually better.';
            
            case 'tr5': // Travel protections
                return 'Trip protections can reimburse thousands in cancelled flight costs. Rental car coverage can replace expensive counter insurance.';
            
            case 'goal': // Initial goal selection
                return 'Cash back is simpler and gives you real money. Travel rewards can offer more value but require more planning.';
                
            default:
                // Generic helpful advice for other steps
                if (state.mode === 'cashback') {
                    return 'Most people succeed with cash back by keeping it simple: one flat-rate card plus one category card for their biggest expense.';
                } else if (state.mode === 'travel') {
                    return 'Travel rewards work best when you focus on a specific strategy: either flexible points OR loyalty to one airline/hotel.';
                } else {
                    return 'The best card strategy is one you\'ll actually use consistently. Start simple and add complexity only if it\'s worth it.';
                }
        }
    }

    function renderZeroState() {
        const grid = document.getElementById('cards-grid');
        currentCards = []; // Reset current cards state when showing zero state
        const nameMap = {
            type:{travel:'Travel',cashback:'Cash back'},
            perks:{'lounge-access':'Lounge Access','no-foreign-fees':'No Foreign Transaction Fees'},
            protections:{'trip-delay-cancellation':'Trip Delay or Cancellation','rental-car-insurance':'Rental Car Insurance','cell-phone-protection':'Phone Protection','lost-delayed-baggage':'Lost/Delayed Baggage','purchase-protection':'Purchase Protection & Extended Warranty'},
            'airline-hotel':{'delta':'Delta','united':'United','american':'American','southwest':'Southwest','jetblue':'JetBlue','alaska':'Alaska','marriott':'Marriott','hilton':'Hilton','hyatt':'Hyatt','ihg':'IHG','wyndham':'Wyndham','choice':'Choice'},
            earning_any:{'flat-rate':'Flat Rate','dining':'Dining','groceries':'Groceries','gas':'Gas','transit':'Transit','travel':'Travel','hotels':'Hotels','flights':'Flights','drugstores':'Drugstores','online':'Online','streaming':'Streaming','telecom':'Telecom','entertainment':'Entertainment','amazon':'Amazon','gas|ev-charging':'Gas/EV Charging','rideshare|transit':'Rideshare/Transit','travel|hotels|airlines':'Travel','wholesale-clubs':'Wholesale Clubs','rent':'Rent'}
        };
        const last = state.lastApplied;
        const lastLabel = last && nameMap[last.key] ? (nameMap[last.key][last.value] || last.value) : 'the last filter';
        
        grid.classList.add('showing-intro');
        grid.innerHTML = `
            <div style="width: 100%; margin: 0; padding: 2.5rem 2rem; text-align: center; background: #fff; border-radius: 16px; border: 1px solid #e5e7eb; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);">
                <!-- Main message -->
                <h3 style="color: #1e293b; font-weight: 600; font-size: 1.25rem; margin-bottom: 0.75rem; line-height: 1.3;">
                    No cards match your exact criteria
                </h3>
                
                <!-- Explanation -->
                <p style="color: #64748b; font-size: 1rem; line-height: 1.6; margin-bottom: 1.5rem; max-width: 400px; margin-left: auto; margin-right: auto;">
                    Your combination of preferences is pretty specific! Try adjusting some of your choices to see more options.
                </p>
                
                <!-- Action buttons -->
                <div style="display: flex; flex-direction: column; gap: 0.75rem; align-items: center;">
                    ${last && last.key ? `
                    <button id="remove-last" style="
                        background: #059669; 
                        color: white; 
                        border: none; 
                        padding: 0.75rem 1.5rem; 
                        border-radius: 8px; 
                        font-weight: 600; 
                        cursor: pointer;
                        font-size: 0.95rem;
                        transition: background 0.2s ease;
                    " onmouseover="this.style.background='#047857'" onmouseout="this.style.background='#059669'">
                        Unselect ${lastLabel}
                    </button>
                    ` : ''}
                </div>
                
                <!-- Helpful tip -->
                <div style="background: #f8fafc; border-left: 3px solid #059669; padding: 1rem; margin-top: 1.5rem; border-radius: 0 8px 8px 0; text-align: left;">
                    <div style="color: #059669; font-weight: 600; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">
                        Tip
                    </div>
                    <div style="color: #475569; font-size: 0.9rem; line-height: 1.5;">
                        ${getContextualTip()}
                    </div>
                </div>
            </div>
        `;
        
        // Wire up the remove last filter button
        const removeBtn = document.getElementById('remove-last');
        if (removeBtn && last && last.key) {
            removeBtn.addEventListener('click', () => removeFilter(last.key, last.value));
        }
        
        
        // Hide mobile scroll indicator when showing zero state
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        if (mobileIndicator) {
            mobileIndicator.style.display = 'none';
        }

        // Hide desktop card count when showing zero state
        const desktopIndicator = document.getElementById('desktop-card-count');
        if (desktopIndicator) {
            desktopIndicator.style.display = 'none';
        }
    }

    function resetAllFilters() {
        console.log('Resetting all filters...');
        
        // Reset all filter states
        state.travelFilters = {};
        state.cashbackFilters = {};
        state.baseFilters = {};
        
        // Reset wizard state to beginning
        state.stepIndex = 0;
        state.mode = null;
        state.lastApplied = null;
        
        // Re-render the wizard and results
        renderStep();
        recomputeAndRender();
        
        // Hide the active filters line
        document.getElementById('active-filters-line').style.display = 'none';
        
        console.log('Filters reset complete. State:', state);
    }
    </script>
</body>
</html>
