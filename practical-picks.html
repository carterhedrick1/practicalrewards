<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TXPB5KSTNP"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-TXPB5KSTNP');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practical Picks - Practical Rewards</title>


    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; overflow-x: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6; color: #292524; background: #fafaf9; overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        header { position: fixed; top: 0; left: 0; right: 0; background: rgba(250,250,249,0.95);
            backdrop-filter: blur(20px); border-bottom: 1px solid rgba(231,229,228,0.6); z-index: 1000; }

        .coach-container { max-width: 1400px; margin: 0 auto; padding: 20px 2rem 0 2rem; }


        /* Layout */
        .coach-layout { display: grid; grid-template-columns: 340px 1fr; gap: 2rem; align-items: start; }
        @media (max-width: 1024px) { 
            .coach-layout { 
                grid-template-columns: 1fr; 
                gap: 0;
            }
            .results-bar {
                margin-bottom: 1.5rem;
                padding: .5rem 1rem;
            }
            .cards-grid {
                gap: 1rem;
                margin: 0;
            }
        }

        /* Wizard */
        .wizard { position: sticky; top: 100px; background: white; border: 1px solid #e5e7eb; border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06); padding: 0.75rem; }
        .wizard-header { margin-bottom: .5rem; }
        .wizard-title { font-size: 1.1rem; font-weight: 700; color: #047857; }
        .wizard-title.question { font-size: 1.3rem; font-weight: 600; color: #047857; line-height: 1.3; }
        .progress { height: 6px; background: #e5e7eb; border-radius: 9999px; overflow: hidden; margin: .5rem 0; }
        .wizard-actions { display: flex; gap: .5rem; align-items: center; justify-content: center; margin-top: .75rem; }
        .progress > span { display: block; height: 100%; width: 0; background: linear-gradient(135deg,#059669,#10b981); transition: width .3s ease; }
        .step { padding: .5rem; border: 1px solid #e5e7eb; border-radius: 10px; margin-bottom: .5rem; }
        .step h3 { font-size: 1rem; color: #1e293b; margin-bottom: .5rem; }
        #steps-container { margin-bottom: .5rem; }
        .options { display: grid; grid-template-columns: 1fr; gap: .5rem; }
        .option { 
            border: 2px solid #e2e8f0; 
            border-radius: 10px; 
            padding: .75rem; 
            background: white; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            gap: .5rem; 
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
            min-height: 44px; /* Minimum touch target size for mobile */
            position: relative;
        }
        
        /* Improve scrolling over options on mobile */
        @media (max-width: 1024px) {
            .option {
                touch-action: pan-y; /* Allow vertical scrolling */
            }
        }
        .option input { 
            margin: 0; 
            pointer-events: none;
        }
        .option.active { border-color: #059669; background: #f0fdf4; }
        .option:active { 
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }
        
        /* Only show hover effects on devices that support hover (not mobile) */
        @media (hover: hover) and (pointer: fine) {
            .option:hover { border-color: #10b981; background: #f9fafb; }
        }
        .btn { padding: .6rem 1rem; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; }
        .btn-primary { background: #059669; color: white; }
        .btn-secondary { background: white; color: #059669; border: 1px solid #059669; }

        /* Context help box in wizard */
        .help-box { 
            margin-top: .5rem; 
            background: #f8fafc; 
            border: 1px solid #e5e7eb; 
            border-left: 3px solid #059669; 
            border-radius: 8px; 
            padding: 1rem; 
            position: relative;
            display: none; /* Hide by default, show when needed */
        }
        .help-title { 
            font-weight: 700; 
            color: #059669; 
            font-size: 1rem; 
            margin-bottom: 0.5rem; 
            text-transform: uppercase; 
            letter-spacing: .5px; 
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        .help-title .expand-icon {
            transition: transform 0.3s ease;
            font-size: 0.9rem;
            color: #059669;
        }
        .help-title.expanded .expand-icon {
            transform: rotate(180deg);
        }
        .help-text { 
            color: #475569; 
            font-size: 0.95rem; 
            line-height: 1.6; 
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, margin-top 0.3s ease;
            margin-top: 0;
        }
        .help-text.expanded {
            max-height: 500px;
            margin-top: 0.5rem;
        }
        
        /* Collapsible states - desktop version with fade and arrow like mobile */
        .help-box.collapsible .help-text {
            max-height: 112px;
            overflow: hidden;
            position: relative;
            transition: max-height 0.3s ease, margin-top 0.3s ease;
            margin-top: 0.5rem;
        }
        
        .help-box.collapsible.expanded .help-text {
            max-height: 500px;
            margin-top: 0.5rem;
        }
        
        .help-box.collapsible.collapsed .help-text {
            max-height: 112px;
            overflow: hidden;
            position: relative;
        }
        
        /* Fade effect and arrow for collapsed state */
        .help-box.collapsed .help-text::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23059669' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") center 85% / 20px 20px no-repeat,
                        linear-gradient(to bottom, rgba(248, 250, 252, 0.15) 0%, rgba(248, 250, 252, 0.35) 30%, rgba(248, 250, 252, 0.65) 65%, #f8fafc 100%);
            pointer-events: none;
            z-index: 1;
        }
        
        .help-box.collapsed .help-title .expand-icon {
            display: none;
        }
        
        /* Explicitly set expanded state to override collapsed max-height */
        .help-box.expanded .help-text {
            max-height: none !important;
            overflow: visible !important;
        }
        
        .help-box.expanded .help-text::after {
            display: none;
        }
        
        .help-box.expanded .help-title .expand-icon {
            display: none;
        }

        /* Content side */
        .results-bar { display: flex; align-items: center; justify-content: space-between; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 12px; padding: .75rem 1rem; margin-bottom: 1rem; }
        .tabs { display: flex; gap: .5rem; }
        .tab { padding: .5rem .9rem; border-radius: 9999px; border: 1px solid #e5e7eb; background: white; cursor: pointer; }
        .tab.active { background: #059669; color: white; border-color: #059669; }

        /* Cards Grid & Card styles copied from cards.html for perfect parity */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin: 0;
            /* Performance optimizations for smooth animations */
            contain: layout style paint;
            transform: translateZ(0); /* Force hardware acceleration */
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Override grid layout when showing intro text */
        .cards-grid.showing-intro {
            display: block;
            grid-template-columns: none;
        }

        .card-item {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            border: 1px solid #e5e7eb;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            color: inherit;
            display: block;
            opacity: 1;
            transform: scale(1);
            text-align: center;
        }

        .card-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .card-item:hover::before { left: 100%; }
        .card-item:hover { transform: translateY(-8px); box-shadow: 0 20px 40px rgba(0,0,0,0.15); border-color: #059669; }
        
        /* Disable card hover effects on mobile devices */
        @media (max-width: 1024px) {
            .card-item:hover { 
                transform: none; 
                box-shadow: 0 2px 12px rgba(0,0,0,0.08); 
                border-color: #e5e7eb; 
            }
            .card-item:hover .card-image { 
                transform: none; 
            }
        }

        .card-image {
            width: 100%;
            max-width: 200px;
            height: 140px;
            object-fit: contain;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            box-shadow: none;
            border: none;
            transition: transform 0.3s ease;
        }

        .card-item:hover .card-image { transform: scale(1.02); }

        .card-image-fallback {
            width: 100%;
            max-width: 240px;
            height: 140px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            box-shadow: none;
            border: none;
        }

        .card-header { display: flex; justify-content: center; align-items: center; margin-bottom: 0.75rem; height: 40px; flex-shrink: 0; }
        .card-title { font-size: 1.1rem; font-weight: 600; color: #1e293b; margin: 0; line-height: 1.3; text-align: center; }
        .card-meta-row { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; flex-wrap: wrap; justify-content: center; height: 32px; align-items: center; flex-shrink: 0; }
        .meta-chip { background: #f1f5f9; color: #64748b; padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 500; white-space: nowrap; }
        .card-earning-rates { color: #374151; margin-bottom: 0.5rem; font-size: 0.8rem; line-height: 1.3; text-align: center; }
        .card-perks { color: #6b7280; font-size: 0.75rem; line-height: 1.3; margin-bottom: 0.5rem; text-align: center; }
        .card-advice { background: #f8fafc; border-left: 3px solid #059669; padding: 1rem; margin-top: 0.75rem; border-radius: 0 8px 8px 0; text-align: center; height: 100px; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .card-advice-label { font-weight: 600; color: #059669; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem; }
        .card-advice-text { color: #475569; font-size: 0.75rem; line-height: 1.4; font-style: italic; text-align: center; max-width: 100%; }

        /* Card transition animations - super smooth and simple */
        .card-item {
            transition: all 0.25s ease-out;
            will-change: opacity, transform;
        }
        
        .card-item.fade-out { 
            opacity: 0; 
            transform: translateY(-5px); 
            pointer-events: none;
        }
        
        .card-item.fade-in { 
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s ease-out;
        }
        

        /* Recommendation list styling (matching card pages) */
        .recommendation-list li strong {
            color: #1e293b !important; /* Black for bold benefit names */
            font-weight: 600 !important;
        }

        .recommendation-list li {
            color: #64748b !important; /* Lighter grey for descriptions */
            font-size: 0.9rem !important; /* Smaller font size */
            line-height: 1.5 !important;
        }

        /* Ensure the text after the dash is styled correctly */
        .help-box .recommendation-list li {
            color: #64748b !important;
            font-size: 0.9rem !important;
        }

        .help-box .recommendation-list li strong {
            color: #1e293b !important;
            font-weight: 600 !important;
        }

        /* Style quiz options with vertical layout */
        .option label {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            width: 100%;
        }

        .option input[type="radio"],
        .option input[type="checkbox"] {
            display: none !important; /* Hide radio buttons completely */
        }

        /* Create a container for the text content */
        .option .text-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            width: 100%;
        }

        /* Style the strong text at top */
        .option .text-content strong {
            color: #1e293b !important;
            font-weight: 600 !important;
            font-size: 0.85rem !important;
            line-height: 1.2 !important;
        }

        /* Style the descriptive text underneath */
        .option .text-content .description {
            color: #64748b !important;
            font-size: 0.9rem !important;
            line-height: 1.4 !important;
        }

        /* Space-efficient grid layout for category options */
        .options.grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            grid-auto-rows: 1fr;
        }

        .options.grid-layout .option {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.75rem 0.5rem;
            min-height: 48px;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 8px;
        }

        .options.grid-layout .option label {
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 0;
            width: 100%;
            height: 100%;
        }

        .options.grid-layout .option.active {
            border-color: #059669;
            background: #f0fdf4;
            transform: scale(1.02);
        }

        .options.grid-layout .option:hover {
            border-color: #10b981;
            background: #f9fafb;
        }

        /* Responsive adjustments for grid */
        @media (max-width: 768px) {
            .options.grid-layout {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.4rem;
            }
        }

        @media (max-width: 480px) {
            .options.grid-layout {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.4rem;
            }
            
            .options.grid-layout .option {
                padding: 0.6rem 0.4rem;
                font-size: 0.85rem;
                min-height: 42px;
            }
        }


        /* Step tip styling */
        .step-tip {
            font-style: italic;
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        /* Desktop tweaks */
        @media (min-width: 769px) {
            /* Hide results bar and filter bar on desktop */
            .results-bar {
                display: none !important;
            }

            #active-filters-line {
                display: none !important;
            }

            /* Desktop card count indicator */
            .desktop-card-count {
                /* visibility controlled by JS; default hidden */
                display: none;
                background: #059669;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                margin: 0 0 1rem 0;
                padding: 0.5rem 0.75rem;
                text-align: center;
                border: none;
            }

            .desktop-card-count-number {
                font-size: 1.25rem;
                font-weight: 700;
                color: white;
                line-height: 1;
                margin-bottom: 0.15rem;
            }

            .desktop-card-count-label {
                font-size: 0.8rem;
                color: white;
                font-weight: 600;
                margin-bottom: 0;
                opacity: 0.9;
            }
        }

        /* Hide desktop indicator on mobile */
        @media (max-width: 768px) {
            .desktop-card-count {
                display: none !important;
            }
        }

        /* Mobile tweaks */
        @media (max-width: 768px) {
            /* Match header/hero behavior from cards page */
            .mobile-menu-toggle { display: flex; }
            .nav-links { display: none; }
            nav { padding: 0 1rem; height: 70px; }

            .coach-container { padding: 20px 1rem 0 1rem; }

            /* Additional mobile improvements for wizard */
            .wizard {
                position: static;
                margin-bottom: 1rem;
                margin-top: 0;
            }
            
            .wizard-header {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                gap: 0.5rem;
            }
            
            .wizard-title {
                flex: 1;
                min-width: 0;
            }
            
            .wizard-actions {
                flex-shrink: 0;
                gap: 0.5rem;
            }
            
            .wizard-actions .btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
                min-width: 60px;
            }
            
            /* Mobile scroll indicator - pinned to bottom */
            .mobile-scroll-indicator {
                background: #059669;
                border-radius: 6px 6px 0 0;
                box-shadow: 0 -2px 8px rgba(0,0,0,0.15);
                margin: 0;
                padding: 0.25rem 0.5rem;
                text-align: center;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100vw;
                z-index: 1000;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.5rem;
                min-height: 40px;
            }
            
            /* Hide results bar and filter bar on mobile */
            .results-bar {
                display: none !important;
            }
            
            #active-filters-line {
                display: none !important;
            }
            
            /* Add bottom padding to prevent content from being hidden behind fixed indicator */
            .cards-grid {
                padding-bottom: 80px !important;
            }
            
            /* Also add padding to main content sections */
            main, section {
                padding-bottom: 80px !important;
            }
            
            .mobile-scroll-count {
                font-size: 1rem;
                font-weight: 700;
                color: white;
                line-height: 1;
                margin: 0;
            }
            
            .mobile-scroll-label {
                font-size: 0.65rem;
                color: white;
                font-weight: 600;
                margin: 0;
                white-space: nowrap;
                opacity: 0.9;
            }
            
            
            /* Collapsible help box for mobile */
            .help-box {
                margin-top: 1rem;
                padding: 1rem;
                background: #f8fafc;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                border-left: 3px solid #059669;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow-x: hidden;
                overflow-y: visible;
                display: none; /* Hide by default on mobile too */
            }
            
            .help-title {
                font-size: 1rem;
                margin-bottom: 0.5rem;
            }
            
            .help-text {
                color: #475569;
                font-size: 0.95rem;
                line-height: 1.6;
                max-height: none;
                overflow-x: hidden;
                overflow-y: visible;
                transition: all 0.3s ease;
                word-wrap: break-word;
                overflow-wrap: break-word;
                hyphens: auto;
                box-sizing: border-box;
                width: 100%;
                max-width: 100%;
            }
            
            /* Collapsible behavior for mobile - expanded by default */
            .help-box.collapsible .help-text {
                max-height: none;
                overflow-x: hidden;
                overflow-y: visible;
                position: relative;
            }
            
            .help-box.collapsible:not(.collapsed) .help-text::after {
                display: none;
            }
            
            .help-box.collapsible .help-title::after {
                content: '▼';
                font-size: 0.8rem;
                transition: transform 0.3s ease;
                margin-left: 0.5rem;
            }
            
            .help-box.expanded .help-title::after {
                /* Hide the arrow entirely when expanded */
                display: none;
            }
            
            /* Collapsed state when content is too long */
            .help-box.collapsed .help-text {
                max-height: 50px;
                overflow: hidden;
                position: relative;
            }

            .help-box.collapsed .help-text::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 40px;
                /* Smaller chevron and fade to take less space */
                background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23059669' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") center 18px / 20px 20px no-repeat,
                            linear-gradient(to bottom, rgba(248, 250, 252, 0.15) 0%, rgba(248, 250, 252, 0.35) 30%, rgba(248, 250, 252, 0.65) 65%, #f8fafc 100%);
                pointer-events: none;
                z-index: 1;
            }
            
            .help-box.collapsed .help-title::after {
                display: none;
            }
            
            /* Explicitly set expanded state to override collapsed max-height */
            .help-box.expanded .help-text {
                max-height: none !important;
                overflow: visible !important;
            }
        }

        /* Celebration animations */
        .celebration-bar {
            background: linear-gradient(90deg, #10b981, #059669, #10b981) !important;
            background-size: 200% 100% !important;
            animation: celebration-shimmer 2s ease-in-out infinite;
        }

        @keyframes celebration-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .completion-title {
            color: #10b981 !important;
            font-weight: 700 !important;
            animation: celebration-bounce 0.6s ease-out;
        }

        .completion-content {
            text-align: center;
            padding: 2rem 0;
            animation: celebration-fade-in 0.8s ease-out;
        }

        .celebration-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #10b981;
            font-weight: bold;
            animation: celebration-scale 0.8s ease-out;
        }

        .completion-message {
            font-size: 1.5rem;
            font-weight: 700;
            color: #10b981;
            margin-bottom: 0.5rem;
            animation: celebration-slide-up 0.8s ease-out 0.2s both;
        }

        .completion-subtitle {
            font-size: 1rem;
            color: #6b7280;
            animation: celebration-slide-up 0.8s ease-out 0.4s both;
        }

        @keyframes celebration-bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes celebration-fade-in {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes celebration-scale {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes celebration-slide-up {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Completion card styling */
        .completion-card {
            animation: completion-glow 0.8s ease-out;
            transition: all 0.3s ease !important;
        }

        .completion-card:hover {
            transform: translateY(-12px) !important;
            box-shadow: 0 12px 35px rgba(16, 185, 129, 0.25) !important;
        }

        @keyframes completion-glow {
            0% { 
                border-color: #e5e7eb;
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            }
            100% { 
                border-color: #10b981;
                box-shadow: 0 8px 25px rgba(16, 185, 129, 0.15);
            }
        }
    </style>
</head>
<body>
    <div id="header-placeholder"></div>

    <div class="coach-container">

        <div class="coach-layout">
            <!-- Wizard -->
            <aside class="wizard" id="wizard">
                <div class="wizard-header">
                    <div class="wizard-title" id="wizard-question">Step-by-step</div>
                </div>
                <div class="progress"><span id="progress-bar"></span></div>

                <div id="steps-container"></div>

                <div class="help-box" id="help-box" aria-live="polite">
                    <div class="help-title" id="help-title">
                        Practical Advice
                        <span class="expand-icon">▼</span>
                    </div>
                    <div class="help-text" id="help-content">
                        <ul class="recommendation-list" style="margin: 0; padding: 0; list-style: none;">
                            <li><strong>Getting started</strong> – Answer the question above. Tips update here.</li>
                        </ul>
                    </div>
                </div>
                
                <div class="wizard-actions">
                    <button class="btn btn-secondary" id="back-btn">Back</button>
                    <button class="btn btn-primary" id="next-btn" style="display: none;">Next</button>
                </div>
            </aside>

            <!-- Mobile scroll indicator (only visible on mobile) -->
            <div class="mobile-scroll-indicator" id="mobile-scroll-indicator" style="display: none;">
                <div class="mobile-scroll-count" id="mobile-scroll-count">0 Cards</div>
                <div class="mobile-scroll-label">Fit Your Criteria So Far</div>
            </div>

            <!-- Results -->
            <section>
                <div class="results-bar">
                    <div>
                        <strong id="results-headline">Found <span id="results-display-count">0</span> cards</strong>
                        <span style="color:#64748b;"> of <span id="results-display-total">0</span> total</span>
                    </div>
                    <div class="tabs" id="mode-tabs" style="display:none;">
                        <button class="tab active" data-tab="cashback">Cash back (<span id="cashback-count">0</span>)</button>
                        <button class="tab" data-tab="travel">Travel (<span id="travel-count">0</span>)</button>
                    </div>
                </div>

                <div id="active-filters-line" class="results-bar" style="display:none;">
                    <div style="display:flex;gap:.5rem;flex-wrap:wrap;" id="active-filters-chips"></div>
                    <button class="btn btn-secondary" onclick="resetAllFilters()">Clear all</button>
                </div>

                <!-- Desktop card count indicator (only visible on desktop) -->
                <div class="desktop-card-count" id="desktop-card-count" style="display: none;">
                    <div class="desktop-card-count-number" id="desktop-card-count-number">0 Cards</div>
                    <div class="desktop-card-count-label">Fit Your Criteria So Far</div>
                </div>

                <div class="cards-grid" id="cards-grid"></div>
            </section>
        </div>
    </div>

    <div id="footer-placeholder"></div>

    <script>
    // --- Header/Footer loader (copied from cards.html for consistency) ---
    document.addEventListener('DOMContentLoaded', function() {
        loadComponent('header.html', 'header-placeholder');
        loadComponent('footer.html', 'footer-placeholder');
        initializeCards().then(() => { initCoach(); });
    });

    function loadComponent(filename, placeholderId) {
        const placeholder = document.getElementById(placeholderId);
        fetch(filename).then(r => r.text()).then(html => {
            if (filename === 'header.html') {
                const cleanHtml = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                placeholder.innerHTML = cleanHtml;
                const scripts = [...html.matchAll(/<script[^>]*>([\s\S]*?)<\/script>/gi)].map(m=>m[1]);
                scripts.forEach(s => { try { eval(s); } catch(e) { console.error(e); } });
                
                // Auto-scroll down past the header after it's loaded (mobile only)
                setTimeout(() => {
                    // Only auto-scroll on mobile devices (viewport width <= 1024px)
                    if (window.innerWidth <= 1024) {
                        const header = document.querySelector('header');
                        if (header) {
                            const headerHeight = header.offsetHeight;
                            window.scrollTo({
                                top: headerHeight,
                                behavior: 'smooth'
                            });
                        }
                    }
                }, 50);
            } else { placeholder.innerHTML = html; }
        }).catch(() => { placeholder.innerHTML = ''; });
    }

    // --- Cards data, rendering, filters (trimmed/adapted from cards.html) ---
    let allCards = [];
    let filteredCards = [];
    let cardsCache = null;
    let isLoading = false;

    async function initializeCards() {
        // Prevent multiple simultaneous requests
        if (isLoading) {
            console.log('🔄 Cards already loading, skipping duplicate request');
            return;
        }
        
        // Show loading state immediately
        showLoadingState();
        
        // Check cache first (valid for 5 minutes)
        if (cardsCache && Date.now() - cardsCache.timestamp < 300000) {
            console.log('✅ Using cached cards data');
            allCards = cardsCache.data;
            filteredCards = [...allCards];
            renderCards(filteredCards);
            updateResultsHeadline(filteredCards.length, allCards.length);
            hideLoadingState();
            return;
        }
        
        isLoading = true;
        
        try {
            console.log('📥 Fetching cards.json...');
            
            const response = await fetch('cards.json', { cache: 'no-store' });
            if (!response.ok) {
                throw new Error(`Failed to fetch cards.json: ${response.status}`);
            }
            
            const databaseCards = await response.json();
            console.log('✅ Static JSON fetch successful, received cards:', databaseCards);
            
            // Convert database format to match your existing code (same as cards.html)
            let allCardsFromDB = databaseCards.map(card => {
                // Helper function to safely parse array data
                const parseArrayField = (field) => {
                    if (!field || field === '0' || field === 0) {
                        return [];
                    }
                    if (Array.isArray(field)) {
                        return field;
                    }
                    if (typeof field === 'string') {
                        try {
                            // Handle double-encoded JSON strings and malformed data
                            let cleanField = field.trim();
                            
                            // Remove surrounding quotes if they exist
                            if (cleanField.startsWith('"') && cleanField.endsWith('"')) {
                                cleanField = cleanField.slice(1, -1);
                            }
                            
                            // Handle cases where the inner content is still quoted
                            if (cleanField.startsWith('"[') && cleanField.endsWith(']"')) {
                                cleanField = cleanField.slice(1, -1);
                            }
                            
                            const parsed = JSON.parse(cleanField);
                            
                            // Clean up any quoted strings within the array
                            if (Array.isArray(parsed)) {
                                return parsed.map(item => {
                                    if (typeof item === 'string' && item.startsWith('"') && item.endsWith('"')) {
                                        return item.slice(1, -1);
                                    }
                                    return item;
                                });
                            }
                            
                            return Array.isArray(parsed) ? parsed : [];
                        } catch (e) {
                            console.warn('Failed to parse array field:', field, e);
                            return [];
                        }
                    }
                    return [];
                };
                
                return {
                    id: card.id,
                    name: card.name,
                    type: card.type,
                    annualFee: card.annual_fee,
                    bankType: card.bank_type,
                    rewards: card.rewards_type,
                    image: card.image_url,
                    welcomeBonus: card.welcome_bonus || card.welcomeBonus || 'None',
                    practicalAdvice: card.practical_advice || card.practicalAdvice || '',
                    features: Array.isArray(card.features) ? card.features : parseArrayField(card.features),
                    perkCategories: parseArrayField(card.perk_categories),
                    protectionCategories: parseArrayField(card.protection_categories),
                    earningCategories: parseArrayField(card.earning_categories),
                    airlineHotel: parseArrayField(card.airline_hotels),
                    url: card.card_url,
                    status: card.status || 'active'
                };
            });
            
            // Filter to only show active cards
            allCards = allCardsFromDB.filter(card => card.status === 'active');
            
            // Cache the results
            cardsCache = {
                data: allCards,
                timestamp: Date.now()
            };
            
            console.log('✅ Loaded cards from static JSON:', allCards.length);
        } catch (e) {
            console.warn('Failed to load cards from database:', e && e.message);
            
            // Show error state instead of fallback cards
            showErrorState(e.message);
        } finally {
            isLoading = false;
            hideLoadingState();
        }
        
        filteredCards = [...allCards];
        renderCards(filteredCards);
        updateResultsHeadline(filteredCards.length, allCards.length);
    }

    function showLoadingState() {
        const cardsGrid = document.getElementById('cards-grid');
        if (cardsGrid) {
            cardsGrid.innerHTML = `
                <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #fff; border-radius: 12px; border: 1px solid #e5e7eb;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <div style="width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top: 3px solid #059669; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="color: #1e293b; font-weight: 600;">Loading credit cards...</div>
                        <div style="color: #64748b; font-size: 0.875rem;">Please wait while we fetch the latest data</div>
                    </div>
                </div>
            `;
            
            // Add CSS animation if not already present
            if (!document.getElementById('loading-spinner-css')) {
                const style = document.createElement('style');
                style.id = 'loading-spinner-css';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
        }
    }

    function hideLoadingState() {
        // The loading state will be replaced when renderCards() is called
        // No need to explicitly hide it here
    }

    function showErrorState(errorMessage) {
        const cardsGrid = document.getElementById('cards-grid');
        if (cardsGrid) {
            cardsGrid.innerHTML = `
                <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #fff; border-radius: 12px; border: 1px solid #e5e7eb;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <div style="width: 48px; height: 48px; background: #fef2f2; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">⚠️</div>
                        <div style="color: #1e293b; font-weight: 600; font-size: 1.125rem;">Unable to load credit cards</div>
                        <div style="color: #64748b; font-size: 0.875rem; max-width: 400px; line-height: 1.5;">
                            We're having trouble connecting to our database. Please check your internet connection and try refreshing the page.
                        </div>
                        <button onclick="window.location.reload()" style="
                            background: #059669; 
                            color: white; 
                            border: none; 
                            padding: 0.75rem 1.5rem; 
                            border-radius: 8px; 
                            font-weight: 600; 
                            cursor: pointer;
                            font-size: 0.875rem;
                        ">Refresh Page</button>
                    </div>
                </div>
            `;
        }
        
        // Clear the cards arrays so nothing renders
        allCards = [];
        filteredCards = [];
        updateResultsHeadline(0, 0);
    }



    function generatePracticalAdvice(card) {
        // Use database practical advice if available, otherwise generate it
        if (card.practical_advice || card.practicalAdvice) {
            return card.practical_advice || card.practicalAdvice;
        }
        // Generate practical advice based on card characteristics (same logic as cards.html)
        if (card.annualFee === 0) {
            if (card.type === 'cashback') {
                return "Perfect starter card with no risk. Use for everyday spending and build credit history.";
            } else if (card.type === 'hybrid') {
                return "Great for renters! Pay rent with this card to earn points on your biggest monthly expense.";
            } else {
                return "No annual fee means this card pays for itself. Great for building credit and earning rewards.";
            }
        } else if (card.annualFee <= 95) {
            if (card.type === 'travel') {
                return "Low annual fee for solid travel benefits. Make sure you'll use the credits to offset the cost.";
            } else {
                return "Modest annual fee for enhanced rewards. Calculate if the extra earning rates justify the cost.";
            }
        } else if (card.annualFee <= 250) {
            if (card.name.includes('Venture X')) {
                return "At $395/year, this is premium travel at a discount. The $300 travel credit + 10k anniversary miles make it worth it if you travel 2+ times per year.";
            } else {
                return "Premium card with significant annual fee. Only worth it if you travel frequently and will use all the credits and benefits.";
            }
        } else {
            if (card.name.includes('Platinum')) {
                return "The $695 fee is steep, but the credits add up quickly. Only get this if you'll use airline credits, hotel credits, and lounge access regularly.";
            } else if (card.name.includes('Reserve')) {
                return "At $795/year, this is Chase's premium offering. The $300 travel credit helps, but you need to travel frequently to justify this cost.";
            } else {
                return "High annual fee card. Carefully calculate if the benefits outweigh the cost for your specific spending patterns.";
            }
        }
    }

    function createCardElement(card) {
        const div = document.createElement('div');
        div.className = 'card-item';
        div.onclick = () => window.location.href = card.url;
        const feeText = card.annualFee === 0 ? 'No AF' : `$${card.annualFee} AF`;
        const welcomeBonus = card.welcomeBonus || 'None';
        const earningRates = Array.isArray(card.features) ? card.features.slice(0,3).join(' • ') : '';
        // Intentionally do not render filter tags on the card in Card Coach
        const advice = generatePracticalAdvice(card);

        div.innerHTML = `
            <img src="${card.image}" alt="${card.name}" class="card-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="card-image-fallback" style="display: none;">${card.name}</div>
            
            <div class="card-header">
                <h3 class="card-title">${card.name}</h3>
            </div>
            
            <div class="card-meta-row">
                <span class="meta-chip">${feeText}</span>
                <span class="meta-chip">Welcome: ${welcomeBonus}</span>
            </div>
            
            <div class="card-earning-rates">
                <strong>Earning:</strong> ${earningRates || '1x on everything'}
            </div>
            
            <div class="card-advice">
                <div class="card-advice-label">Practical Advice</div>
                <div class="card-advice-text">${advice}</div>
            </div>
        `;
        return div;
    }

    function isCompletionStep() {
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        return currentStep && currentStep.type === 'completion';
    }

    let currentCards = []; // Track currently displayed cards for animation

    function renderCards(cards) {
        const grid = document.getElementById('cards-grid');
        grid.classList.remove('showing-intro');
        
        const isCompletion = isCompletionStep();
        
        // Get currently displayed card IDs
        const currentCardIds = new Set(currentCards.map(c => c.id));
        const newCardIds = new Set(cards.map(c => c.id));
        
        // Find cards to remove and cards to add
        const cardsToRemove = currentCards.filter(c => !newCardIds.has(c.id));
        const cardsToAdd = cards.filter(c => !currentCardIds.has(c.id));
        const cardsToKeep = cards.filter(c => currentCardIds.has(c.id));
        
        // If this is the first render or a major change, just render immediately
        if (currentCards.length === 0 || cards.length === 0) {
            renderCardsImmediate(cards, isCompletion);
            currentCards = [...cards];
            return;
        }
        
        // Handle animated transitions
        if (cardsToRemove.length > 0 || cardsToAdd.length > 0) {
            handleAnimatedCardTransition(cardsToRemove, cardsToAdd, cardsToKeep, isCompletion);
        }
        
        currentCards = [...cards];

        // Update mobile scroll indicator (but not during completion)
        if (!isCompletion) {
            updateMobileScrollIndicator(cards);
        }

        // Update desktop card count (but not during completion)
        if (!isCompletion) {
            updateDesktopCardCount(cards);
        }
    }
    
    function renderCardsImmediate(cards, isCompletion) {
        const grid = document.getElementById('cards-grid');
        grid.innerHTML = '';
        
        cards.forEach((c, index) => {
            const cardElement = createCardElement(c);
            
            // Add special styling for completion step
            if (isCompletion) {
                cardElement.style.border = '3px solid #10b981';
                cardElement.style.boxShadow = '0 8px 25px rgba(16, 185, 129, 0.15)';
                cardElement.classList.add('completion-card');
            } else {
                // Add fade-in animation for new cards
                cardElement.classList.add('fade-in');
                // Remove the animation class after animation completes
                setTimeout(() => {
                    cardElement.classList.remove('fade-in');
                }, 500 + (index * 50)); // Account for stagger delay
            }
            
            grid.appendChild(cardElement);
        });
    }
    
    function handleAnimatedCardTransition(cardsToRemove, cardsToAdd, cardsToKeep, isCompletion) {
        const grid = document.getElementById('cards-grid');
        const totalNewCards = cardsToAdd.length;
        
        // Set adaptive stagger class based on number of cards
        grid.className = grid.className.replace(/\b(fast|normal)-stagger\b/g, '');
        if (totalNewCards > 8) {
            grid.classList.add('fast-stagger');
        } else {
            grid.classList.add('normal-stagger');
        }
        
        // Use requestAnimationFrame for smooth animations
        if (cardsToRemove.length > 0) {
            // Batch fade-out operations
            requestAnimationFrame(() => {
                const existingElements = Array.from(grid.children);
                const elementsToFadeOut = [];
                
                existingElements.forEach(element => {
                    const cardId = element.querySelector('.card-title')?.textContent;
                    if (cardsToRemove.some(c => c.name === cardId)) {
                        element.classList.add('fade-out');
                        elementsToFadeOut.push(element);
                    }
                });
                
                // Wait for fade-out animation to complete
                if (elementsToFadeOut.length > 0) {
                    // Use transitionend event for better timing
                    let completedTransitions = 0;
                    const onTransitionEnd = () => {
                        completedTransitions++;
                        if (completedTransitions >= elementsToFadeOut.length) {
                            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                        }
                    };
                    
                    elementsToFadeOut.forEach(element => {
                        element.addEventListener('transitionend', onTransitionEnd, { once: true });
                    });
                    
                    // Fallback timeout in case transitionend doesn't fire
                    setTimeout(() => {
                        if (completedTransitions < elementsToFadeOut.length) {
                            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                        }
                    }, 300);
                } else {
                    updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
                }
            });
        } else {
            // No cards to remove, add new ones immediately
            updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion);
        }
    }
    
    function updateGridWithNewCards(cardsToAdd, cardsToKeep, isCompletion) {
        const grid = document.getElementById('cards-grid');
        
        // Batch DOM operations for better performance
        requestAnimationFrame(() => {
            // Remove faded out cards in one batch
            const elementsToRemove = Array.from(grid.querySelectorAll('.fade-out'));
            elementsToRemove.forEach(element => element.remove());
            
            // Create all new card elements before adding to DOM
            const newElements = cardsToAdd.map((card, index) => {
                const cardElement = createCardElement(card);
                
                if (isCompletion) {
                    cardElement.style.border = '3px solid #10b981';
                    cardElement.style.boxShadow = '0 8px 25px rgba(16, 185, 129, 0.15)';
                    cardElement.classList.add('completion-card');
                } else {
                    // Set initial invisible state for smooth fade-in
                    cardElement.style.opacity = '0';
                    cardElement.style.transform = 'translateY(10px)';
                }
                
                return cardElement;
            });
            
            // Add all elements to DOM in one batch operation
            const fragment = document.createDocumentFragment();
            newElements.forEach(element => fragment.appendChild(element));
            grid.appendChild(fragment);
            
            // Trigger smooth staggered fade-in
            if (!isCompletion && newElements.length > 0) {
                newElements.forEach((element, index) => {
                    setTimeout(() => {
                        requestAnimationFrame(() => {
                            element.classList.add('fade-in');
                        });
                    }, index * 50);
                });
            }
        });
    }

    function showIntroText() {
        const grid = document.getElementById('cards-grid');
        grid.classList.add('showing-intro');
        currentCards = []; // Reset current cards state when showing intro
        grid.innerHTML = `
            <div style="width: 100%; margin: 0; padding: 2rem; text-align: center; background: #059669; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.15);">
                <h2 style="color: white; margin-bottom: 1.5rem; font-size: 1.5rem; font-weight: 600;">We built Practical Picks to help you find the right card for your life.</h2>
                <p style="color: white; opacity: 0.9; font-size: 1rem; line-height: 1.6; margin-bottom: 1rem;">
                    Answer a few quick questions and tell us what matters—cash back, travel, lounges, no foreign fees, or keeping it simple. Then we put our practical research to work and surface cards that actually fit your goals.
                </p>
                <p style="color: white; opacity: 0.9; font-size: 1rem; line-height: 1.6; margin: 0;">
                    The result? Clear, personalized options you can choose from.
                </p>
            </div>
        `;

        // Hide mobile scroll indicator when showing intro
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        if (mobileIndicator) {
            mobileIndicator.style.display = 'none';
        }

        // Hide desktop card count when showing intro
        const desktopIndicator = document.getElementById('desktop-card-count');
        if (desktopIndicator) {
            desktopIndicator.style.display = 'none';
        }
    }

    function updateResultsHeadline(count, total) {
        const c = document.getElementById('results-display-count');
        const t = document.getElementById('results-display-total');
        if (c) c.textContent = count; if (t) t.textContent = total;
    }

    function updateResultsHeadlineForQuiz() {
        const headline = document.getElementById('results-headline');
        if (headline) {
            headline.innerHTML = 'Find your perfect card';
        }
    }

    // --- Filtering helpers (map to existing data fields) ---
    function getIssuerCategory(card) {
        const b = (card.bankType || '').toLowerCase();
        const n = (card.name || '').toLowerCase();
        if (b.includes('amex') || n.includes('american express')) return 'amex';
        if (b.includes('chase') || n.includes('chase')) return 'chase';
        if (b.includes('capital-one') || n.includes('capital one') || n.includes('venture')) return 'capital-one';
        if (b.includes('citi') || n.includes('citi')) return 'citi';
        if (b.includes('discover') || n.includes('discover')) return 'discover';
        if (b.includes('wells') || n.includes('wells fargo')) return 'wells-fargo';
        return 'other';
    }

    function inferBrandTags(card) {
        const name = (card.name || '').toLowerCase();
        const tags = new Set(Array.isArray(card.airlineHotel) ? card.airlineHotel.map(v => (v||'').toLowerCase()) : []);
        const brandMap = {
            'delta':'delta', 'united':'united', 'aa ':'american', 'aadvantage':'american',
            'southwest':'southwest', 'jetblue':'jetblue', 'alaska':'alaska',
            'marriott':'marriott', 'hilton':'hilton', 'hyatt':'hyatt', 'ihg':'ihg', 'wyndham':'wyndham', 'choice':'choice'
        };
        
        // Special handling for American Airlines to avoid false positives with American Express
        if (name.includes('american airlines') || name.includes('aa ') || name.includes('aadvantage')) {
            tags.add('american');
        }
        
        // Check other brands (excluding 'american' to avoid American Express false positives)
        Object.keys(brandMap).forEach(k => { 
            if (k !== 'american' && name.includes(k)) {
                tags.add(brandMap[k]); 
            }
        });
        
        return Array.from(tags);
    }

    function applyFiltersTo(cards, filters) {
        return cards.filter(card => {
            // First, apply flat-rate exclusion if user has a 2% everywhere card
            if (state.cashbackFilters.hasFlatRate) {
                const earningCats = Array.isArray(card.earningCategories) ? card.earningCategories : [];
                if (earningCats.includes('flat-rate')) {
                    console.log(`❌ ${card.name} filtered out - user already has 2% everywhere card, excluding flat-rate`);
                    return false;
                }
                // Also check for "flat-rate" with quotes (in case of double encoding)
                if (earningCats.includes('"flat-rate"')) {
                    console.log(`❌ ${card.name} filtered out - user already has 2% everywhere card, excluding "flat-rate"`);
                    return false;
                }
            }

            for (const [k, values] of Object.entries(filters)) {
                if (!values || values.length === 0) continue;
                if (k === 'type') {
                    // Handle arrays, single strings, and JSON-stringified arrays
                    let cardType;
                    if (Array.isArray(card.type)) {
                        cardType = card.type;
                    } else if (typeof card.type === 'string' && card.type.trim().startsWith('[') && card.type.trim().endsWith(']')) {
                        try { cardType = JSON.parse(card.type); } catch(e) { cardType = [card.type]; }
                    } else {
                        cardType = [card.type];
                    }
                    if (!values.some(v => cardType.includes(v))) return false;
                } else if (k === 'issuer') {
                    if (!values.includes(getIssuerCategory(card))) return false;
                } else if (k === 'perks') {
                    const perks = card.perkCategories || [];
                    console.log(`🔍 Filtering ${card.name} for perks:`, values, 'Card has perks:', perks);
                    // Use OR logic for perks - card must have ANY selected perk
                    const hasAnyPerk = values.some(v => perks.includes(v));
                    if (!hasAnyPerk) {
                        console.log(`❌ ${card.name} filtered out - missing any required perk(s)`);
                        return false;
                    }
                } else if (k === 'protections') {
                    const prots = card.protectionCategories || [];

                    // Strict mode: card must have ALL of the selected protections
                    let allMatches = true;
                    for (const selectedValue of values) {
                        if (!prots.includes(selectedValue)) {
                            allMatches = false;
                            break;
                        }
                    }

                    if (!allMatches) return false;
                } else if (k === 'airline-hotel') {
                    const brandsOnCard = inferBrandTags(card);
                    if (!values.some(v => brandsOnCard.includes(v))) return false;
                } else if (k === 'earning_any') {
                    const earningCats = Array.isArray(card.earningCategories) ? card.earningCategories : [];

                    console.log(`🔍 Filtering ${card.name} for earning_any:`, values, 'Card has earning categories:', earningCats);

                    // Exclude Citi Custom Cash when 2+ categories selected (it can only do 1 category)
                    if (values.length >= 2 && card.name === 'Citi Custom Cash® Card') {
                        console.log(`❌ ${card.name} filtered out - can only handle 1 category, ${values.length} selected`);
                        return false;
                    }

                    // Strict mode: card must have ALL of the selected categories/groups
                    let allMatches = true;

                    for (const selectedValue of values) {
                        // Handle grouped categories (e.g., "gas|ev-charging")
                        const selectedOptions = selectedValue.split('|');
                        const hasMatchForGroup = selectedOptions.some(option => earningCats.includes(option));

                        if (!hasMatchForGroup) {
                            allMatches = false;
                            break;
                        }
                    }

                    console.log(`🔍 ${card.name} strict mode: ${allMatches ? 'matches all' : 'missing some'} categories`);

                    if (!allMatches) {
                        console.log(`❌ ${card.name} filtered out - needs ALL matching categories`);
                        return false;
                    } else {
                        console.log(`✅ ${card.name} passed strict earning filter`);
                    }
                } else if (k === 'fee') {
                    if (values.includes('0-100') && !(card.annualFee >= 0 && card.annualFee <= 100)) return false;
                    if (values.includes('100-300') && !(card.annualFee >= 100 && card.annualFee <= 300)) return false;
                    if (values.includes('300-500') && !(card.annualFee >= 300 && card.annualFee <= 500)) return false;
                    if (values.includes('500+') && !(card.annualFee >= 500)) return false;
                } else if (k === 'focus') {
                    const brandsOnCard = inferBrandTags(card);
                    const hasAirlineOrHotelBrand = brandsOnCard.length > 0;
                    
                    if (values.includes('flex')) {
                        // For flexible points, exclude cards with any airline or hotel brands
                        if (hasAirlineOrHotelBrand) {
                            console.log(`❌ ${card.name} filtered out - has airline/hotel brand(s): ${brandsOnCard.join(', ')}, not flexible points`);
                            return false;
                        }
                    } else if (values.includes('airline')) {
                        // For airline cards, only show cards with airline brands
                        const airlineBrands = ['delta', 'united', 'american', 'southwest', 'jetblue', 'alaska'];
                        const hasAirlineBrand = brandsOnCard.some(brand => airlineBrands.includes(brand));
                        if (!hasAirlineBrand) {
                            console.log(`❌ ${card.name} filtered out - not an airline card`);
                            return false;
                        }
                    } else if (values.includes('hotel')) {
                        // For hotel cards, only show cards with hotel brands
                        const hotelBrands = ['marriott', 'hilton', 'hyatt', 'ihg', 'wyndham', 'choice'];
                        const hasHotelBrand = brandsOnCard.some(brand => hotelBrands.includes(brand));
                        if (!hasHotelBrand) {
                            console.log(`❌ ${card.name} filtered out - not a hotel card`);
                            return false;
                        }
                    }
                }
            }
            return true;
        });
    }

    // --- Coach state & flow ---
    const state = {
        stepIndex: 0,
        steps: [],
        mode: null,  // travel | cashback | either
        baseFilters: {},
        travelFilters: {},
        cashbackFilters: {},
        activeTab: 'cashback',
        lastApplied: null
    };

    function getCurrentFilteredCards() {
        if (!state.mode) return allCards;
        
        if (state.mode === 'either') {
            const cashFilters = mergeFilters({ type: ['cashback'] }, state.cashbackFilters);
            const travFilters = mergeFilters({ type: ['travel'] }, state.travelFilters);
            return state.activeTab === 'cashback' ? applyFiltersTo(allCards, cashFilters) : applyFiltersTo(allCards, travFilters);
        }
        
        const base = {};
        if (state.mode === 'cashback') base.type = ['cashback'];
        if (state.mode === 'travel') base.type = ['travel'];
        const merged = mergeFilters(base, state.mode === 'travel' ? state.travelFilters : state.cashbackFilters);
        return applyFiltersTo(allCards, merged);
    }

    function updateMobileScrollIndicator(cards) {
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        const mobileCount = document.getElementById('mobile-scroll-count');

        if (!mobileIndicator || !mobileCount) return;

        // Hide during completion step
        if (isCompletionStep()) {
            mobileIndicator.style.display = 'none';
            return;
        }

        // Only show on mobile and when there are cards to show
        if (window.innerWidth <= 768 && cards.length > 0) {
            mobileIndicator.style.display = 'block';
            mobileCount.textContent = cards.length + ' Cards';
        } else {
            mobileIndicator.style.display = 'none';
        }
    }

    function updateDesktopCardCount(cards) {
        const desktopIndicator = document.getElementById('desktop-card-count');
        const desktopCount = document.getElementById('desktop-card-count-number');

        if (!desktopIndicator || !desktopCount) return;

        // Hide during completion step
        if (isCompletionStep()) {
            desktopIndicator.style.display = 'none';
            return;
        }

        // Only show on desktop and when there are cards to show, and when a mode is selected
        if (window.innerWidth > 768 && cards.length > 0 && state.mode) {
            desktopIndicator.style.display = 'block';
            desktopCount.textContent = cards.length + ' Cards';
        } else {
            desktopIndicator.style.display = 'none';
        }
    }

    function bindHelpBoxToggle() {
        const helpBox = document.getElementById('help-box');
        const helpTitle = helpBox.querySelector('.help-title');
        const helpText = helpBox.querySelector('.help-text');
        
        // Check if content height exceeds threshold - make it collapse more aggressively like mobile
        function shouldCollapse() {
            if (!helpText) return false;
            const contentHeight = helpText.scrollHeight;
            return contentHeight > 100; // Much lower threshold to match mobile behavior
        }
        
        // Add collapsible behavior on both mobile and desktop
        function checkMobileAndSetup() {
            helpBox.classList.add('collapsible');
            
            // Start collapsed to show text with fade effect like mobile
            helpBox.classList.add('collapsed');
            
            // Remove any existing click listeners to avoid duplicates
            const newHelpTitle = helpBox.querySelector('.help-title');
            const newHelpText = helpBox.querySelector('.help-text');
            
            function handleToggle() {
                helpBox.classList.toggle('expanded');
                helpBox.classList.toggle('collapsed');
                // Update cursor based on state
                const isCollapsed = helpBox.classList.contains('collapsed');
                newHelpText.style.cursor = isCollapsed ? 'pointer' : 'default';
                helpBox.style.cursor = isCollapsed ? 'pointer' : 'default';
            }
            
            newHelpTitle.removeEventListener('click', handleToggle);
            newHelpTitle.addEventListener('click', handleToggle);
            
            // Also make the collapsed text area clickable (for the bottom arrow)
            newHelpText.removeEventListener('click', handleToggle);
            newHelpText.addEventListener('click', handleToggle);

            // As a safety net on mobile Safari, toggle when tapping anywhere in the help box
            function containerToggle(e) {
                // Don't toggle when tapping links inside the advice text
                const isLink = e.target.closest && e.target.closest('a');
                if (isLink) return;
                // Only toggle when currently collapsed to prevent accidental collapses when expanded
                if (helpBox.classList.contains('collapsed')) {
                    handleToggle();
                }
            }
            helpBox.removeEventListener('click', containerToggle);
            helpBox.addEventListener('click', containerToggle);
            
            // Set initial cursor based on collapsed state
            const isInitiallyCollapsed = helpBox.classList.contains('collapsed');
            newHelpText.style.cursor = isInitiallyCollapsed ? 'pointer' : 'default';
            helpBox.style.cursor = isInitiallyCollapsed ? 'pointer' : 'default';
        }
        
        // Setup on load
        checkMobileAndSetup();
        
        // Re-setup on resize
        window.addEventListener('resize', checkMobileAndSetup);
        
        // Also update mobile scroll indicator on resize
        window.addEventListener('resize', () => {
            if (state.mode && allCards.length > 0) {
                const currentCards = getCurrentFilteredCards();
                updateMobileScrollIndicator(currentCards);
                updateDesktopCardCount(currentCards);
            }
        });
    }

    function initCoach() {
        // Clear all filter states to ensure no pre-selections
        clearAllFilterStates();
        
        buildSteps();
        bindWizardControls();
        bindHelpBoxToggle();
        renderStep();
        recomputeAndRender();
    }
    
    function clearAllFilterStates() {
        // Reset all filter states to empty
        state.cashbackFilters = {
            earning_any: [],
            protections: []
        };
        state.travelFilters = {
            'airline-hotel': [],
            earning_any: [],
            protections: []
        };
        state.lastApplied = null;
    }

    function buildSteps() {
        state.steps = [
            {
                id: 'goal',
                title: 'What’s your goal right now?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>I want to earn cash back</strong></div>', value: 'cashback' },
                    { label: '<div class="text-content"><strong>I want to earn travel rewards</strong></div>', value: 'travel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'not-sure' }
                ],
                help: 'If you are new or undecided, start with Cash Back. It is simple, real money, and a great baseline.<br><br>If you\'re experienced, or okay putting in some additional work, you can get more value out of travel cards. Know your own personality, because it is more work.<br><br>If you really have no idea, we\'d recommend learning more about each option <a href="learning.html" style="color: #059669; text-decoration: underline;">here</a> and coming back.',
                onAnswer: (val) => { 
                    state.mode = val; 
                    // Always jump to the first branch step upon selecting a goal
                    state.stepIndex = 1; 
                    state.lastApplied = null; 
                    configureModeTabs();
                    recomputeAndRender();
                    // Render the next step immediately for all choices
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Not sure flow - Question 1: Do you travel?
            {
                id: 'ns1', branch: 'not-sure',
                title: 'Do you ever travel?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                onAnswer: (val) => {
                    state.notSureAnswers = state.notSureAnswers || {};
                    state.notSureAnswers.travels = val === 'yes';
                    if (val === 'no') {
                        // Route directly to cash-back flow
                        state.mode = 'cashback';
                        configureModeTabs();
                        state.stepIndex = 0; // Set after configureModeTabs to override its default
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                    }
                    // If yes, continue to next question (step will auto-advance)
                }
            },
            // Not sure flow - Question 2: How hands-on?
            {
                id: 'ns2', branch: 'not-sure',
                title: 'How hands-on do you want to be?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Lower maintenance</strong></div>', value: 'low' },
                    { label: '<div class="text-content"><strong>I\'ll put in the work</strong></div>', value: 'high' }
                ],
                help: 'This is a personality call. If you like simple routines and hate fine print, go <strong>"Lower maintenance"</strong>. If you enjoy tinkering and don\'t mind a few extra steps for more upside, pick <strong>"I\'ll put in the work"</strong>. There\'s no right answer—choose the one that matches your personality.',
                onAnswer: (val) => {
                    state.notSureAnswers = state.notSureAnswers || {};
                    state.notSureAnswers.handsOn = val === 'high';
                    
                    if (val === 'low') {
                        // Route to cash-back flow (fewer rules, steady results)
                        state.mode = 'cashback';
                        configureModeTabs();
                        state.stepIndex = 0; // Set after configureModeTabs to override its default
                    } else {
                        // Route to travel flow (more moving parts, higher upside)
                        state.mode = 'travel';
                        configureModeTabs(); // This sets stepIndex = 1, which goes to tr2
                        state.stepIndex = 0; // Override to 0 to start with tr1 (international travel question)
                    }
                    
                    recomputeAndRender();
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Travel mini-quiz Q0: First travel card?
            {
                id: 'tmq0', branch: 'travel-mini-quiz',
                title: 'Would this be your first travel card?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'If you\'ve never opened a card mainly for flights, hotels, or travel perks, pick Yes. Everyday cash-back cards don\'t count here.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.firstTravelCard = val === 'yes';
                    
                    if (val === 'yes') {
                        // Route to Flexible points path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['flex'];
                        configureModeTabs();
                        state.stepIndex = 2; // Skip tr1 (international) and tr2 (focus), go to next step
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    // If no, continue to next question
                }
            },
            // Travel mini-quiz Q1: Same airline?
            {
                id: 'tmq1', branch: 'travel-mini-quiz',
                title: 'Do you mostly fly the same airline?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes, mostly one</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No, I mix it up</strong></div>', value: 'no' }
                ],
                help: 'Think about last year (or next). If you usually start with one airline—or fly it more often than not—that\'s a Yes.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.airlineLoyal = val === 'yes';
                    // Continue to next question
                }
            },
            // Travel mini-quiz Q2: Same hotel chain?
            {
                id: 'tmq2', branch: 'travel-mini-quiz',
                title: 'Do you mostly stay with one hotel chain?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes, mostly one</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No, I mix it up</strong></div>', value: 'no' }
                ],
                help: 'If you find yourself booking the same hotel brand on most trips, that\'s a Yes. If you chase price or location across brands, pick No.',
                onAnswer: (val) => {
                    state.travelMiniQuizAnswers = state.travelMiniQuizAnswers || {};
                    state.travelMiniQuizAnswers.hotelLoyal = val === 'yes';
                    
                    const airlineLoyal = state.travelMiniQuizAnswers.airlineLoyal;
                    const hotelLoyal = val === 'yes';
                    
                    // Route based on loyalty combinations
                    if (!airlineLoyal && !hotelLoyal) {
                        // Flexible points path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['flex'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    } else if (airlineLoyal && !hotelLoyal) {
                        // Airline path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['airline'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    } else if (!airlineLoyal && hotelLoyal) {
                        // Hotel path
                        state.mode = 'travel';
                        state.travelFilters.focus = ['hotel'];
                        configureModeTabs();
                        state.stepIndex = 2;
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    // If both are loyal, continue to Q3
                }
            },
            // Travel mini-quiz Q3: What sounds nicer?
            {
                id: 'tmq3', branch: 'travel-mini-quiz',
                title: 'What sounds nicer this year?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Free checked bags & earlier boarding</strong></div>', value: 'airline' },
                    { label: '<div class="text-content"><strong>A free hotel night & status perks</strong></div>', value: 'hotel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'not-sure' }
                ],
                help: 'Go with what sounds better for your trips this year. If it\'s a toss-up, Not sure is honest.',
                onAnswer: (val) => {
                    state.mode = 'travel';
                    
                    if (val === 'airline') {
                        state.travelFilters.focus = ['airline'];
                    } else if (val === 'hotel') {
                        state.travelFilters.focus = ['hotel'];
                    } else {
                        // Not sure -> Flexible points
                        state.travelFilters.focus = ['flex'];
                    }
                    
                    configureModeTabs();
                    state.stepIndex = 2;
                    recomputeAndRender();
                    setTimeout(() => {
                        renderStep();
                    }, 300);
                }
            },
            // Cashback path
            {
                id: 'cb1', branch: 'cashback',
                title: 'Do you already have a Flat Rate Card?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'A <strong>Flat Rate Card</strong> earns the same cash back on almost every purchase. No categories to track. Simple and predictable. These cards typically offer 1.5%–2% everywhere—much better than the standard 1%. If you only want one card, this is the easy choice. Swipe and move on.\n\nIf you want to optimize your setup, start with a Flat Rate Card as your default. Use category cards when they beat your flat rate. The Flat Rate Card quietly covers everything else.\n\nEither way—simple or optimized—a <strong>Flat Rate Card</strong> is your practical starting point.',
                onAnswer: (val) => {
                    // Store the user's answer for step visibility logic
                    state.cashbackFilters.hasFlatRate = val === 'yes';
                    console.log(`🔍 Set hasFlatRate to:`, state.cashbackFilters.hasFlatRate, 'for answer:', val);
                    
                    const arr = state.cashbackFilters['earning_any'] || [];
                    if (val === 'no') {
                        // They don't have flat-rate, show them flat-rate cards
                        if (!arr.includes('flat-rate')) arr.push('flat-rate');
                        state.lastApplied = { key: 'earning_any', value: 'flat-rate' };
                    } else {
                        // They already have flat-rate, focus on categories instead
                        state.cashbackFilters['earning_any'] = arr.filter(v => v !== 'flat-rate');
                        state.lastApplied = { key: 'earning_any', value: 'flat-rate' };
                    }
                    state.cashbackFilters['earning_any'] = Array.from(new Set(state.cashbackFilters['earning_any'] || arr));
                }
            },
            {
                id: 'cb2', branch: 'cashback',
                title: 'Where do you want more cash back?',
                tip: 'Choose your top category, then add others to find cards that hit multiple categories—results will match <u>all</u> categories you select.',
                type: 'checkbox',
                options: [
                    { label: 'Dining / Bars', value: 'dining' },
                    { label: 'Groceries', value: 'groceries' },
                    { label: 'Gas/EV Charging', value: 'gas|ev-charging' },
                    { label: 'Travel', value: 'travel|hotels|airlines' },
                    { label: 'Rideshare/Transit', value: 'rideshare|transit' },
                    { label: 'Streaming', value: 'streaming' },
                    { label: 'Drugstores', value: 'drugstores' },
                    { label: 'Entertainment', value: 'entertainment' },
                    { label: 'Wholesale Clubs', value: 'wholesale-clubs' },
                    { label: 'Amazon', value: 'amazon' }
                ],
                help: 'Once you\'ve got a <strong>Flat Rate Card</strong> baseline, add cards that pay higher rates where you actually spend. Pick 1–2 to start; your Flat Rate Card covers the rest.\n\nCategory rules vary by card. We\'ll flag common quirks (exclusions, caps, portal-only rates) so there are no surprises.\n\n• <strong>Dining & bars</strong> — restaurants, fast food, delivery apps, coffee shops\n• <strong>Groceries</strong> — supermarkets; big-box/warehouse stores (Walmart, Target, Costco, Sam\'s Club) usually don\'t count as groceries.\n• <strong>Gas / EV charging</strong> — gas stations and many public chargers.\n• <strong>Travel</strong> — flights, hotels, and other travel. Terms vary by card—some require booking through the issuer\'s portal; others count direct bookings. Check the card\'s details.\n• <strong>Transit / rideshare</strong> — subways, buses, trains, parking, tolls, Uber/Lyft.\n• <strong>Drugstores</strong> — Walgreens, CVS, and many independents.\n• <strong>Entertainment</strong> — tickets for movies, concerts, sports, museums, zoos.\n• <strong>Wholesale clubs</strong> — Costco, Sam\'s Club (codes differently than groceries).\n• <strong>Amazon</strong> — The Amazon Credit card is amazing if you shop on Amazon. 5% back on everything!\n\nNot sure what to pick? Go with the categories you hit every month. Your Flat Rate Card backs up everything else.',
                onAnswer: (vals) => {
                    // Replace the earning_any array with the new selections (allows deselection)
                    state.cashbackFilters['earning_any'] = [...vals];
                    if (vals.length > 0) {
                        state.lastApplied = { key: 'earning_any', value: vals[vals.length - 1] };
                    } else {
                        // Clear lastApplied if no categories are selected
                        state.lastApplied = null;
                    }

                    // Update toggle state when categories change
                    setTimeout(() => renderStep(), 0);
                }
            },
            {
                id: 'cb3', branch: 'cashback',
                title: 'What protections matter to you?',
                tip: 'Choose your top protection, then add others to find cards that offer multiple protections—results will match <u>all</u> protections you select.',
                type: 'checkbox',
                options: [
                    { label: '<div class="text-content"><strong>Phone protection</strong></div>', value: 'cell-phone-protection' },
                    { label: '<div class="text-content"><strong>Purchase protection & extended warranty</strong></div>', value: 'purchase-protection' }
                ],
                help: 'Protections aren\'t as exciting as rewards, but they can save real money when something goes wrong.\n\n<strong>Phone protection</strong>\nPay your monthly cell phone bill with the card; if a covered phone is accidentally damaged or stolen, you can file a claim. It applies to every line on that bill, so one card can cover multiple phones. This can let you drop paid phone insurance like AppleCare+ or carrier add-ons.\n\n<strong>Purchase protection & extended warranty</strong>\nPay with the card, keep your receipt, and if an eligible item is damaged, stolen, or fails within the covered window, you can file a claim. Terms, caps, and exclusions vary by card.',
                onAnswer: (vals) => { state.cashbackFilters.protections = vals; }
            },
            // Travel path - International question first
            {
                id: 'tr1', branch: 'travel',
                title: 'Do you travel outside the U.S. at least once a year?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Yes</strong></div>', value: 'yes' },
                    { label: '<div class="text-content"><strong>No</strong></div>', value: 'no' }
                ],
                help: 'If you go abroad even once a year, a <strong>no foreign transaction fee</strong> card is an easy win—about <strong>3%</strong> saved on every purchase (including online charges in foreign currency). That\'s $30 for every $1000 that you spend.',
                onAnswer: (val) => {
                    const arr = new Set(state.travelFilters.perks || []);
                    if (val === 'yes') { arr.add('no-foreign-fees'); state.lastApplied = { key: 'perks', value: 'no-foreign-fees' }; }
                    else { arr.delete('no-foreign-fees'); state.lastApplied = { key: 'perks', value: 'no-foreign-fees' }; }
                    state.travelFilters.perks = Array.from(arr);
                }
            },
            {
                id: 'tr2', branch: 'travel',
                title: 'What do you want most right now?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Flexible Points</strong></div>', value: 'flex' },
                    { label: '<div class="text-content"><strong>Airline Perks</strong></div>', value: 'airline' },
                    { label: '<div class="text-content"><strong>Hotel Perks</strong></div>', value: 'hotel' },
                    { label: '<div class="text-content"><strong>I\'m not sure, help me decide</strong></div>', value: 'none' }
                ],
                help: 'If you\'re just getting started, go with <strong>flexible points</strong> (also called bank points). This is what people mean by "Amex points" or "Capital One Miles." You earn on everyday spending, then use them to book on any airline or hotels.\n\n<strong>Airline and hotel cards</strong> are different. You\'re earning rewards tied to one brand, and the value shows up as that brand\'s perks—think a free night or a checked-bag benefit.\n\nFlexible points cards usually earn more on everyday spend, while airline or hotel cards are mostly about perks—so lean flexible unless your brand loyalty makes those extras a clear win.',
                onAnswer: (val) => {
                    if (val === 'none') {
                        // Redirect to travel mini-quiz
                        state.mode = 'travel-mini-quiz';
                        state.stepIndex = 1; // Go to first travel mini-quiz question (tmq0)
                        configureModeTabs();
                        recomputeAndRender();
                        setTimeout(() => {
                            renderStep();
                        }, 300);
                        return;
                    }
                    state.travelFilters.focus = [val];
                    // Do not hard filter issuer; only controls visibility of brand step
                }
            },
            {
                id: 'tr2b', branch: 'travel',
                title: 'Do you need airport lounge access?',
                type: 'radio',
                options: [
                    { label: '<div class="text-content"><strong>Must Have</strong></div>', value: 'must' },
                    { label: '<div class="text-content"><strong>Nice To Have</strong></div>', value: 'nice' }
                ],
                help: 'Lounge access usually comes with the most premium cards. Choose <strong>Must-have</strong> only if it\'s a dealbreaker—otherwise pick <strong>Nice to have</strong> to keep more options open.',
                onAnswer: (val) => {
                    if (val === 'must') { 
                        // When lounge access is Must Have, ONLY filter for lounge access
                        state.travelFilters.perks = ['lounge-access'];
                        state.lastApplied = { key: 'perks', value: 'lounge-access' }; 
                    } else if (val === 'nice') { 
                        // When nice to have, remove lounge-access but keep other perks
                        const arr = new Set(state.travelFilters.perks || []);
                        arr.delete('lounge-access'); 
                        state.travelFilters.perks = Array.from(arr);
                        state.lastApplied = { key: 'perks', value: 'lounge-access' }; 
                    }
                }
            },
            {
                id: 'tr3', branch: 'travel',
                title: 'Which brand? (check any)',
                type: 'checkbox',
                getOptions: () => {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    if (focus === 'airline') {
                        return [
                            { label: 'Delta', value: 'delta' },
                            { label: 'United', value: 'united' },
                            { label: 'American', value: 'american' },
                            { label: 'Southwest', value: 'southwest' },
                            { label: 'JetBlue', value: 'jetblue' },
                            { label: 'Alaska', value: 'alaska' }
                        ];
                    } else if (focus === 'hotel') {
                        return [
                            { label: 'Marriott', value: 'marriott' },
                            { label: 'Hilton', value: 'hilton' },
                            { label: 'Hyatt', value: 'hyatt' },
                            { label: 'IHG', value: 'ihg' },
                            { label: 'Wyndham', value: 'wyndham' },
                            { label: 'Choice', value: 'choice' }
                        ];
                    } else {
                        // Fallback to all options
                        return [
                            { label: 'Delta', value: 'delta' },
                            { label: 'United', value: 'united' },
                            { label: 'American', value: 'american' },
                            { label: 'Southwest', value: 'southwest' },
                            { label: 'JetBlue', value: 'jetblue' },
                            { label: 'Alaska', value: 'alaska' },
                            { label: 'Marriott', value: 'marriott' },
                            { label: 'Hilton', value: 'hilton' },
                            { label: 'Hyatt', value: 'hyatt' },
                            { label: 'IHG', value: 'ihg' },
                            { label: 'Wyndham', value: 'wyndham' },
                            { label: 'Choice', value: 'choice' }
                        ];
                    }
                },
                help: 'Pick the airline or hotel you actually use. If none, leave blank to keep more options.',
                onAnswer: (vals) => { state.travelFilters['airline-hotel'] = vals; }
            },
            {
                id: 'tr4', branch: 'travel',
                title: 'Where do you want more rewards?',
                tip: 'Choose your top category, then add others to find cards that hit multiple categories—results will match all categories you select.',
                type: 'checkbox',
                options: [
                    { label: 'Flat Rate', value: 'flat-rate' },
                    { label: 'Rent', value: 'rent' },
                    { label: 'Dining / Bars', value: 'dining' },
                    { label: 'Groceries', value: 'groceries' },
                    { label: 'Gas/EV Charging', value: 'gas|ev-charging' },
                    { label: 'Travel', value: 'travel|hotels|airlines' },
                    { label: 'Rideshare/Transit', value: 'rideshare|transit' },
                    { label: 'Streaming', value: 'streaming' },
                    { label: 'Drugstores', value: 'drugstores' },
                    { label: 'Entertainment', value: 'entertainment' }
                ],
                help: 'Trips start here. Want simple? Go flat-rate and stop thinking about it. Big on dining or groceries? Grab a food card and let dinner pay for flights. You know your spend—pick what actually matters to you.\n\n• <strong>Flat Rate</strong> — The glue. Works everywhere and you don\'t have to think.\n• <strong>Rent</strong> — Only one card offers points on rent, it\'s a pretty sweet setup.\n• <strong>Dining & bars</strong> — restaurants, fast food, delivery apps, coffee shops\n• <strong>Groceries</strong> — supermarkets; big-box/warehouse stores (Walmart, Target, Costco, Sam\'s Club) usually don\'t count as groceries.\n• <strong>Gas / EV charging</strong> — gas stations and many public chargers.\n• <strong>Travel</strong> — flights, hotels, and other travel. Terms vary by card—some require booking through the issuer\'s portal; others count direct bookings. Check the card\'s details.\n• <strong>Transit / rideshare</strong> — subways, buses, trains, parking, tolls, Uber/Lyft.\n• <strong>Drugstores</strong> — Walgreens, CVS, and many independents.\n• <strong>Entertainment</strong> — tickets for movies, concerts, sports, museums, zoos.',
                onAnswer: (vals) => {
                    // Replace the earning_any array with the new selections (allows deselection)
                    state.travelFilters['earning_any'] = [...vals];
                    if (vals.length > 0) {
                        state.lastApplied = { key: 'earning_any', value: vals[vals.length - 1] };
                    } else {
                        // Clear lastApplied if no categories are selected
                        state.lastApplied = null;
                    }

                    // Update toggle state when categories change
                    setTimeout(() => renderStep(), 0);
                }
            },
            {
                id: 'tr5', branch: 'travel',
                title: 'What travel protections matter to you?',
                tip: 'Choose your top protection, then add others to find cards that offer multiple protections—results will match <u>all</u> protections you select.',
                type: 'checkbox',
                options: [
                    { label: '<div class="text-content"><strong>Trip Delay or Cancellation</strong></div>', value: 'trip-delay-cancellation' },
                    { label: '<div class="text-content"><strong>Rental Car Insurance</strong></div>', value: 'rental-car-insurance' },
                    { label: '<div class="text-content"><strong>Lost or Delayed Baggage</strong></div>', value: 'lost-delayed-baggage' }
                ],
                help: 'Travel protections aren\'t as exciting as rewards, but they can save real money when something goes wrong.\n\n<strong>Trip delay & cancellation</strong>\nIf your trip is delayed or cancelled due to covered reasons (weather, mechanical issues, etc.), you can file a claim for expenses like meals, hotels, and transportation. Coverage amounts and time thresholds vary by card.\n\n<strong>Rental car CDW (Collision Damage Waiver)</strong>\nPrimary CDW is best—it covers damage without involving your personal auto insurance. Secondary CDW only kicks in after your personal insurance. Always decline the rental company\'s expensive coverage when you have primary CDW.\n\n<strong>Lost/Delayed baggage</strong>\nIf your checked bags are lost, stolen, or delayed, you can file a claim for essential items and replacement costs. Coverage amounts and time requirements vary by card.',
                onAnswer: (vals) => { state.travelFilters.protections = vals; }
            },
            // Completion step - shows for all branches
            {
                id: 'completion',
                title: 'Congratulations!',
                type: 'completion',
                branch: 'all'
            }
        ];
    }

    function visibleSteps() {
        const steps = state.steps.filter(s => {
            if (!s.branch) return true;
            if (s.id === 'completion') {
                // Show completion step when we're on or past the last regular step
                const regularSteps = state.steps.filter(step => {
                    if (!step.branch) return true;
                    if (state.mode === 'travel') {
                        if (step.id === 'tr2b') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus === 'flex' || focus === 'airline';
                        }
                        if (step.id === 'tr3') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus === 'airline' || focus === 'hotel';
                        }
                        if (step.id === 'tr4') {
                            const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                            return focus !== 'airline' && focus !== 'hotel';
                        }
                        return step.branch === 'travel';
                    }
                    if (state.mode === 'cashback') {
                        if (step.id === 'cb2' && state.cashbackFilters.hasFlatRate === false) {
                            return false;
                        }
                        return step.branch === 'cashback';
                    }
                    if (state.mode === 'not-sure') {
                        return step.branch === 'not-sure';
                    }
                    if (state.mode === 'travel-mini-quiz') {
                        return step.branch === 'travel-mini-quiz';
                    }
                    return false;
                });
                return state.stepIndex >= regularSteps.length - 1;
            }
            if (state.mode === 'travel') {
                if (s.id === 'tr2b') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus === 'flex' || focus === 'airline';
                }
                if (s.id === 'tr3') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus === 'airline' || focus === 'hotel';
                }
                if (s.id === 'tr4') {
                    const focus = Array.isArray(state.travelFilters.focus) ? state.travelFilters.focus[0] : null;
                    return focus !== 'airline' && focus !== 'hotel';
                }
                return s.branch === 'travel';
            }
            if (state.mode === 'cashback') {
                // Skip categories step (cb2) if they don't have a flat-rate card (answered 'no' to cb1)
                if (s.id === 'cb2' && state.cashbackFilters.hasFlatRate === false) {
                    return false;
                }
                return s.branch === 'cashback';
            }
            if (state.mode === 'not-sure') {
                return s.branch === 'not-sure';
            }
            if (state.mode === 'travel-mini-quiz') {
                return s.branch === 'travel-mini-quiz';
            }
            return false;
        });
        return steps;
    }

    function clearFiltersFromFutureSteps(currentStepIndex) {
        const steps = visibleSteps();
        const currentMode = state.mode;
        
        // Determine which filter set to modify
        let targetFilters;
        if (currentMode === 'travel') {
            targetFilters = state.travelFilters;
        } else if (currentMode === 'cashback') {
            targetFilters = state.cashbackFilters;
        } else if (currentMode === 'travel-mini-quiz') {
            targetFilters = state.travelFilters;
        } else {
            // For 'either' mode, don't clear anything since they're still on goal step
            return;
        }
        
        // Clear filters from steps after the current one (not including current step)
        for (let i = currentStepIndex + 1; i < steps.length; i++) {
            const step = steps[i];
            const filterKey = stepToFilterKey(step.id);
            
            if (filterKey && targetFilters[filterKey]) {
                console.log(`Clearing filter ${filterKey} from step ${step.id}`);
                delete targetFilters[filterKey];
            }
        }
        
        // Clear lastApplied if it was from a future step
        state.lastApplied = null;
    }

    function bindWizardControls() {
        const backBtn = document.getElementById('back-btn');
        // Remove any existing listeners to prevent duplicates
        backBtn.replaceWith(backBtn.cloneNode(true));
        const newBackBtn = document.getElementById('back-btn');
        
        newBackBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Back button clicked, current stepIndex:', state.stepIndex, 'mode:', state.mode);
            const steps = visibleSteps();
            console.log('🔍 Visible steps:', steps.map((s, i) => `${i}: ${s.id}`));
            console.log('🔍 Current step:', steps[state.stepIndex] ? steps[state.stepIndex].id : 'undefined');
            
            // Special case: if we're in travel mode but came from travel-mini-quiz, 
            // and we're at the end showing results, go back to tr2 (focus question)
            if (state.mode === 'travel' && state.travelFilters.focus && state.travelMiniQuizAnswers) {
                console.log('Going back from travel mini-quiz results to tr2 (focus question)');
                // Clear the focus filter and mini-quiz answers
                delete state.travelFilters.focus;
                delete state.travelMiniQuizAnswers;
                // Go to tr2 step (flexible/airline/hotel question)
                state.stepIndex = 1; // tr2 is at index 1 in travel mode
                renderStep();
                recomputeAndRender();
                return;
            }
            
            if (state.stepIndex > 0) { 
                // Clear the selection from the current step before going back
                const currentSteps = visibleSteps();
                const currentStep = currentSteps[state.stepIndex];
                if (currentStep) {
                    const filterKey = stepToFilterKey(currentStep.id);
                    if (filterKey) {
                        // Determine which filter set to modify
                        let targetFilters;
                        if (state.mode === 'travel') {
                            targetFilters = state.travelFilters;
                        } else if (state.mode === 'cashback') {
                            targetFilters = state.cashbackFilters;
                        }
                        
                        if (targetFilters && targetFilters[filterKey]) {
                            console.log(`Clearing current step filter: ${filterKey} from step ${currentStep.id}`);
                            delete targetFilters[filterKey];
                        }
                    }
                }
                
                state.stepIndex--; 
                console.log('Going back to stepIndex:', state.stepIndex);
                
                // Special handling: if we're going back TO the lounge access question (tr2b),
                // clear the lounge access filter so the question truly starts fresh
                const newCurrentSteps = visibleSteps();
                const newCurrentStep = newCurrentSteps[state.stepIndex];
                if (newCurrentStep && newCurrentStep.id === 'tr2b' && state.mode === 'travel') {
                    // Remove lounge-access from perks array but keep other perks
                    if (state.travelFilters.perks) {
                        const perksArray = new Set(state.travelFilters.perks);
                        perksArray.delete('lounge-access');
                        state.travelFilters.perks = Array.from(perksArray);
                        // If perks array is now empty, delete the property entirely
                        if (state.travelFilters.perks.length === 0) {
                            delete state.travelFilters.perks;
                        }
                        console.log('Cleared lounge-access filter when returning to tr2b');
                    }
                }
                
                // Clear filters from future steps after we've moved back
                clearFiltersFromFutureSteps(state.stepIndex);
                
                // If going back to the goal step (index 0), reset mode and filters
                if (state.stepIndex === 0) {
                    state.mode = null;
                    state.travelFilters = {};
                    state.cashbackFilters = {};
                    state.activeTab = null;
                    configureModeTabs();
                }
                
                renderStep(); 
                recomputeAndRender();
            } else {
                console.log('Already at first step, cannot go back');
            }
        });
        document.getElementById('next-btn').addEventListener('click', () => {
            const steps = visibleSteps();
            if (state.stepIndex < steps.length - 1) { 
                state.stepIndex++; 
                renderStep(); 
                recomputeAndRender(); // Re-render cards when advancing steps
            }
        });
        document.getElementById('mode-tabs').addEventListener('click', (e) => {
            const btn = e.target.closest('.tab'); if (!btn) return;
            document.querySelectorAll('#mode-tabs .tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            state.activeTab = btn.dataset.tab;
            recomputeAndRender();
        });
    }

    function renderStep() {
        const steps = visibleSteps();
        const total = Math.max(steps.length, 1);
        // Ensure stepIndex is within bounds of visible steps
        const current = Math.min(Math.max(state.stepIndex, 0), total - 1);
        // Don't overwrite state.stepIndex here - it should only be changed by navigation actions
        const step = steps[current];
        
        console.log('🔍 renderStep - mode:', state.mode, 'stepIndex:', state.stepIndex, 'current:', current);
        console.log('🔍 visibleSteps:', steps.map(s => s.id));
        console.log('🔍 current step:', step ? step.id : 'none');
        const container = document.getElementById('steps-container');
        const bar = document.getElementById('progress-bar');

        if (!step) { 
            const questionEl = document.getElementById('wizard-question');
            questionEl.textContent = 'Step-by-step';
            questionEl.className = 'wizard-title';
            container.innerHTML = '<div style="color:#64748b;">All set. Adjust answers on the left anytime.</div>'; 
            bar.style.width = '100%'; 
            updateHelp(null); 
            return; 
        }

        // Handle completion step with celebration
        if (step.type === 'completion') {
            const questionEl = document.getElementById('wizard-question');
            questionEl.textContent = step.title;
            questionEl.className = 'wizard-title completion-title';
            
            // Green progress bar for completion
            bar.style.width = '100%';
            bar.style.backgroundColor = '#10b981';
            bar.classList.add('celebration-bar');
            
            // Celebration content
            container.innerHTML = `
                <div class="completion-content">
                    <div class="celebration-icon">✓</div>
                    <h2 class="completion-message">We've narrowed all the cards to ones that match you!</h2>
                    <p class="completion-subtitle">Your personalized recommendations are ready.</p>
                </div>
            `;
            
            // Hide navigation buttons
            document.getElementById('next-btn').style.display = 'none';
            document.getElementById('back-btn').style.display = 'none';
            
            // Explicitly hide card count indicators
            const desktopIndicator = document.getElementById('desktop-card-count');
            if (desktopIndicator) {
                desktopIndicator.style.display = 'none';
            }
            const mobileIndicator = document.getElementById('mobile-scroll-indicator');
            if (mobileIndicator) {
                mobileIndicator.style.display = 'none';
            }
            
            updateHelp(null);
            
            // Re-render cards with completion styling and hide card count
            recomputeAndRender();
            return;
        }

        const idx = current; bar.style.width = ((idx / total) * 100) + '%';

        // Build options UI
        const selected = getCurrentAnswer(step.id);
        // Get options from either static array or dynamic function
        const options = step.getOptions ? step.getOptions() : step.options;
        let optionsHtml = '';
        if (step.type === 'radio') {
            optionsHtml = options.map(opt => {
                const isSelected = selected === opt.value;
                const checked = isSelected ? 'checked' : '';
                const activeClass = isSelected ? 'active' : '';
                return `<label class="option ${activeClass}"><input type="radio" name="${step.id}" value="${opt.value}" ${checked}/> ${opt.label}</label>`;
            }).join('');
        } else if (step.type === 'checkbox') {
            const selectedArr = Array.isArray(selected) ? selected : [];
            optionsHtml = options.map(opt => {
                const checked = selectedArr.includes(opt.value) ? 'checked' : '';
                return `<label class="option ${checked? 'active':''}"><input type="checkbox" name="${step.id}" value="${opt.value}" ${checked}/> ${opt.label}</label>`;
            }).join('');
        }

        // Apply grid layout for category steps that have many options
        const shouldUseGrid = (step.id === 'cb2' || step.id === 'tr3' || step.id === 'tr4') && step.type === 'checkbox';
        const optionsClass = shouldUseGrid ? 'options grid-layout' : 'options';
        
        // Put the question in the header and options in the container
        const questionEl = document.getElementById('wizard-question');
        questionEl.textContent = step.title;
        questionEl.className = 'wizard-title question';

        // Add tip if it exists
        const tipHtml = step.tip ? `<div class="step-tip">${step.tip}</div>` : '';
        container.innerHTML = `${tipHtml}<div class="${optionsClass}">${optionsHtml}</div>`;

        // Always clear all selections first, then apply current answer if it exists
        container.querySelectorAll('.option').forEach(option => {
            option.classList.remove('active');
            const input = option.querySelector('input');
            if (input) input.checked = false;
        });
        
        // Now apply the current answer if it exists and is valid
        if (selected && ((step.type === 'radio' && selected) || (step.type === 'checkbox' && Array.isArray(selected) && selected.length > 0))) {
            if (step.type === 'radio') {
                const option = container.querySelector(`input[value="${selected}"]`);
                if (option) {
                    option.checked = true;
                    option.closest('.option').classList.add('active');
                }
            } else if (step.type === 'checkbox') {
                selected.forEach(value => {
                    const option = container.querySelector(`input[value="${value}"]`);
                    if (option) {
                        option.checked = true;
                        option.closest('.option').classList.add('active');
                    }
                });
            }
        }

        updateHelp(step);

        // Show/hide Next button based on step type and position
        const nextBtn = document.getElementById('next-btn');
        const backBtn = document.getElementById('back-btn');
        const isLastStep = current >= steps.length - 1;
        const isFirstStep = current === 0;
        
        // Show/hide back button - hide on first step
        if (isFirstStep) {
            backBtn.style.display = 'none';
        } else {
            backBtn.style.display = 'inline-block';
        }
        
        if (step.type === 'checkbox' && step.id !== 'completion') {
            // Show Next button for checkbox steps (except completion step)
            nextBtn.style.display = 'inline-block';
        } else {
            // Hide Next button for radio steps (they auto-advance) and completion step
            nextBtn.style.display = 'none';
        }

        // Wire inputs and make entire options clickable
        container.querySelectorAll('.option').forEach(option => {
            const input = option.querySelector('input');
            let isProcessing = false;
            let touchStarted = false;

            // Handle selection logic
            const handleSelection = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Prevent double-tap issues
                if (isProcessing) return;
                isProcessing = true;
                
                // Small delay to prevent rapid successive taps
                setTimeout(() => { isProcessing = false; }, 150);

                if (step.type === 'radio') {
                    // Exclusive select
                    container.querySelectorAll('input').forEach(cb => cb.checked = false);
                    input.checked = true;
                    // Visual state
                    container.querySelectorAll('.option').forEach(l => l.classList.remove('active'));
                    option.classList.add('active');
                    // Apply answer and auto-advance (except for goal step)
                    step.onAnswer(input.value);
                    recomputeAndRender();
                    
                    // Don't auto-advance for the goal step - it handles its own navigation
                    if (step.id !== 'goal') {
                        setTimeout(() => {
                            const steps = visibleSteps();
                            if (state.stepIndex < steps.length - 1) {
                                state.stepIndex++;
                                renderStep();
                                recomputeAndRender(); // Re-render cards when auto-advancing
                            }
                        }, 300);
                    }
                } else if (step.type === 'checkbox') {
                    // Toggle selection
                    input.checked = !input.checked;
                    // Visual state
                    option.classList.toggle('active', input.checked);
                    const vals = Array.from(container.querySelectorAll('input:checked')).map(cb => cb.value);
                    step.onAnswer(vals);
                    state.lastApplied = { key: stepToFilterKey(step.id), value: input.value };
                    recomputeAndRender();
                }
            };

            // Track touch movement to distinguish between tap and scroll
            let touchStartX = 0;
            let touchStartY = 0;
            let touchMoved = false;

            const handleTouchStart = (e) => {
                touchStarted = true;
                touchMoved = false;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            };

            const handleTouchMove = (e) => {
                if (!touchStarted) return;
                
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // If moved more than 10px, consider it a scroll gesture
                if (deltaX > 10 || deltaY > 10) {
                    touchMoved = true;
                }
            };

            const handleTouchEnd = (e) => {
                if (!touchStarted) return;
                
                // Only trigger selection if it was a tap (no movement)
                if (!touchMoved) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleSelection(e);
                }
                
                touchStarted = false;
                touchMoved = false;
            };

            // Add event listeners
            option.addEventListener('click', handleSelection);
            option.addEventListener('touchstart', handleTouchStart, { passive: true });
            option.addEventListener('touchmove', handleTouchMove, { passive: true });
            option.addEventListener('touchend', handleTouchEnd, { passive: false });
        });
    }

    function stepToFilterKey(stepId) {
        if (stepId.startsWith('cb')) return stepId === 'cb3' ? 'protections' : 'earning_any';
        if (stepId === 'tr2') return 'focus'; // This is the flexible/airline/hotel focus question
        if (stepId === 'tr2b') return 'perks'; // This is the lounge access question
        if (stepId === 'tr3') return 'airline-hotel'; // This is the brand selection
        if (stepId === 'tr4') return 'earning_any'; // This is the earning categories
        if (stepId === 'tr5') return 'protections'; // This is the travel protections
        // Travel mini-quiz steps should clear the focus filter when going back
        if (stepId.startsWith('tmq')) return 'focus';
        return null;
    }

    function updateHelp(step) {
        const helpEl = document.getElementById('help-content');
        const box = document.getElementById('help-box');
        if (!helpEl || !box) return;
        
        // Hide the help box when no step
        if (!step) {
            box.style.display = 'none';
            return;
        }
        
        // Show the help box for all other steps
        box.style.display = 'block';
        
        if (!step.help) {
            helpEl.innerHTML = '<ul class="recommendation-list" style="margin: 0; padding: 0; list-style: none;"><li>Answering "Yes" doesn\'t mean we are going to start recommending you crazy cards, we are just tyring to get to know you!</li></ul>';
        } else {
            // For each step, show its helper
            // Split the help text by double line breaks and create proper paragraphs
            const paragraphs = step.help.split('\n\n');
            const htmlContent = paragraphs.map(para => {
                // Replace single line breaks with <br> tags for proper line breaks
                const formattedPara = para.replace(/\n/g, '<br>');
                return `<p style="margin: 0 0 1rem 0; color: #64748b; font-size: 0.9rem; line-height: 1.6;">${formattedPara}</p>`;
            }).join('');
            helpEl.innerHTML = `<div>${htmlContent}</div>`;
        }
        
        // Reset practical advice to collapsed state for both mobile and desktop
        if (box.classList.contains('collapsible')) {
            const helpText = box.querySelector('.help-text');
            if (helpText) {
                // Always start collapsed when moving to a new step
                box.classList.add('collapsed');
                box.classList.remove('expanded');
                helpText.style.cursor = 'pointer';
                box.style.cursor = 'pointer';
                
                // Ensure click handlers are attached
                const helpTitle = box.querySelector('.help-title');
                const handleToggle = () => {
                    box.classList.toggle('expanded');
                    box.classList.toggle('collapsed');
                    // Update cursor based on state
                    const isCollapsed = box.classList.contains('collapsed');
                    helpText.style.cursor = isCollapsed ? 'pointer' : 'default';
                    box.style.cursor = isCollapsed ? 'pointer' : 'default';
                };
                helpTitle.removeEventListener('click', handleToggle);
                helpTitle.addEventListener('click', handleToggle);
                helpText.removeEventListener('click', handleToggle);
                helpText.addEventListener('click', handleToggle);

                // Container-level handler so tapping the down-arrow overlay always expands
                function containerToggle(e) {
                    const isLink = e.target.closest && e.target.closest('a');
                    if (isLink) return;
                    if (box.classList.contains('collapsed')) {
                        handleToggle();
                    }
                }
                box.removeEventListener('click', containerToggle);
                box.addEventListener('click', containerToggle);
            }
        }
    }

    function getCurrentAnswer(stepId) {
        if (stepId === 'stage') return state.stage;
        if (stepId === 'goal') return state.mode;

        // Return current filter state for specific steps
        if (stepId === 'cb2') return state.cashbackFilters['earning_any'] || [];
        if (stepId === 'cb3') return state.cashbackFilters.protections || [];
        if (stepId === 'tr2') return state.travelFilters.focus ? state.travelFilters.focus[0] : null;
        if (stepId === 'tr2b') return null; // Always reset - no pre-selection
        if (stepId === 'tr3') return state.travelFilters['airline-hotel'] || [];
        if (stepId === 'tr4') return state.travelFilters['earning_any'] || [];
        if (stepId === 'tr5') return state.travelFilters.protections || [];

        // For cb1 (Do you already have a Flat Rate Card?), return null to ensure no pre-selection
        if (stepId === 'cb1') return null;

        // For other travel/cashback steps, derive from filters or return null
        if (stepId.startsWith('tr')) return null;
        if (stepId.startsWith('cb')) return null;
        return null;
    }

    function configureModeTabs() {
        const tabs = document.getElementById('mode-tabs');
        if (state.mode) { 
            tabs.style.display = 'none'; 
            state.activeTab = state.mode; 
            // When a goal is chosen, always start at the first step of that branch
            if (state.mode === 'travel-mini-quiz') {
                state.stepIndex = 0; // Start at tmq0 for travel mini-quiz
            } else {
                state.stepIndex = 1;
            }
        } else {
            // No mode selected (after reset)
            tabs.style.display = 'none';
            state.activeTab = null;
        }
    }

    function recomputeAndRender() {
        const total = allCards.length;
        let showCards = [];
        
        console.log('Recomputing with state:', state);

        // If no mode is selected (still in quiz), show intro text instead of cards
        if (!state.mode) {
            console.log('No mode selected, showing intro text');
            showIntroText();
            updateActiveFilterChipsUI({});
            updateResultsHeadlineForQuiz();
            return;
        }
        
        // If in travel mini-quiz, show all travel cards
        if (state.mode === 'travel-mini-quiz') {
            console.log('In travel mini-quiz, showing all travel cards');
            const travelCards = allCards.filter(card => {
                let cardType;
                if (Array.isArray(card.type)) {
                    cardType = card.type;
                } else if (typeof card.type === 'string' && card.type.trim().startsWith('[') && card.type.trim().endsWith(']')) {
                    try { cardType = JSON.parse(card.type); } catch(e) { cardType = [card.type]; }
                } else {
                    cardType = [card.type];
                }
                return cardType.includes('travel');
            });
            updateActiveFilterChipsUI({});
            updateResultsHeadline(travelCards.length, total);
            renderCards(travelCards);
            return;
        }

        // Single mode
        const base = {};
        if (state.mode === 'cashback') base.type = ['cashback'];
        if (state.mode === 'travel') base.type = ['travel'];
        if (state.mode === 'not-sure') {
            // For not-sure mode, show all cards initially
            updateActiveFilterChipsUI({});
            updateResultsHeadline(allCards.length, total);
            renderCards(allCards);
            return;
        }
        const merged = mergeFilters(base, state.mode === 'travel' ? state.travelFilters : state.cashbackFilters);
        const cards = applyFiltersTo(allCards, merged);
        updateActiveFilterChipsUI(merged);
        updateResultsHeadline(cards.length, total);
        if (cards.length === 0) { renderZeroState(); } else { renderCards(cards); }
    }

    function mergeFilters(a, b) {
        const out = JSON.parse(JSON.stringify(a || {}));
        Object.entries(b || {}).forEach(([k,v]) => { if (v && v.length) out[k] = Array.isArray(v) ? [...v] : [v]; });
        return out;
    }

    function updateActiveFilterChipsUI(filters) {
        const container = document.getElementById('active-filters-chips');
        const line = document.getElementById('active-filters-line');
        container.innerHTML = '';
        
        // Handle case where filters is null/undefined or empty
        if (!filters || Object.keys(filters).length === 0) { 
            line.style.display = 'none'; 
            return; 
        }
        
        const entries = Object.entries(filters).filter(([_,vals]) => vals && vals.length);
        if (entries.length === 0) { 
            line.style.display = 'none'; 
            return; 
        }
        
        line.style.display = 'flex';
        const nameMap = {
            type:{travel:'Travel',cashback:'Cash back'},
            issuer:{'amex':'American Express','chase':'Chase','capital-one':'Capital One','citi':'Citi','wells-fargo':'Wells Fargo','discover':'Discover'},
            perks:{'lounge-access':'Lounge Access','tsa-precheck':'TSA PreCheck','clear':'CLEAR','no-foreign-fees':'No Foreign Transaction Fees','free-checked-bags':'Free Checked Bags','priority-boarding':'Priority Boarding','annual-free-night':'Annual Free Night','automatic-elite-status':'Elite Status','rotating':'Rotating','flat-rate':'Flat Rate'},
            'airline-hotel':{'delta':'Delta','united':'United','american':'American','southwest':'Southwest','jetblue':'JetBlue','alaska':'Alaska','marriott':'Marriott','hilton':'Hilton','hyatt':'Hyatt','ihg':'IHG','wyndham':'Wyndham','choice':'Choice'},
            protections:{'trip-delay-cancellation':'Trip Protections','rental-car-insurance':'Rental Car Insurance','cell-phone-protection':'Cell Phone Protection','lost-delayed-baggage':'Lost/Delayed Baggage'},
            earning_any:{'flat-rate':'Flat Rate','dining':'Dining','groceries':'Groceries','gas':'Gas','transit':'Transit','travel':'Travel','hotels':'Hotels','flights':'Flights','drugstores':'Drugstores','online':'Online','streaming':'Streaming','telecom':'Telecom','entertainment':'Entertainment','amazon':'Amazon','gas|ev-charging':'Gas/EV Charging','rideshare|transit':'Rideshare/Transit','travel|hotels|airlines':'Travel','wholesale-clubs':'Wholesale Clubs'}
        };
        entries.forEach(([k,vals]) => {
            vals.forEach(v => {
                const chip = document.createElement('div');
                chip.className = 'meta-chip';
                chip.style.background = '#059669'; chip.style.color = 'white'; chip.style.borderRadius = '20px';
                chip.style.display = 'inline-flex'; chip.style.alignItems = 'center'; chip.style.gap = '.4rem';
                chip.innerHTML = `${(nameMap[k]&&nameMap[k][v])||v} <button style="all:unset; cursor:pointer; font-weight:700;">×</button>`;
                chip.querySelector('button').addEventListener('click', ()=>{ removeFilter(k, v); });
                container.appendChild(chip);
            });
        });
    }

    function removeFilter(key, value) {
        // Determine which filter set to modify based on current mode
        let target;
        if (state.mode === 'travel') {
            target = state.travelFilters;
        } else if (state.mode === 'cashback') {
            target = state.cashbackFilters;
        } else if (state.mode === 'either') {
            // For "either" mode, modify the active tab's filter set
            target = state.activeTab === 'cashback' ? state.cashbackFilters : state.travelFilters;
        } else {
            // If no mode is set, don't modify anything
            return;
        }
        
        if (!target[key]) return;
        target[key] = target[key].filter(v => v !== value);
        if (target[key].length === 0) delete target[key];
        
        // Update the visual state of the wizard step to reflect the change
        renderStep();
        recomputeAndRender();
    }

    function clearCurrentStepSelections() {
        // Get the current step to determine what to clear
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        if (!currentStep) return;
        
        // Get the filter key for this step
        const filterKey = stepToFilterKey(currentStep.id);
        if (!filterKey) return;
        
        // Determine which filter set to modify based on current mode
        let target;
        if (state.mode === 'travel') {
            target = state.travelFilters;
        } else if (state.mode === 'cashback') {
            target = state.cashbackFilters;
        } else if (state.mode === 'either') {
            target = state.activeTab === 'cashback' ? state.cashbackFilters : state.travelFilters;
        } else {
            return;
        }
        
        // Clear only this step's selections
        if (target[filterKey]) {
            delete target[filterKey];
        }
        
        // Clear lastApplied if it was from this step
        if (state.lastApplied && state.lastApplied.key === filterKey) {
            state.lastApplied = null;
        }
        
        // Update the visual state and results
        renderStep();
        recomputeAndRender();
    }

    function getContextualTip() {
        // Get the current step to provide relevant advice
        const steps = visibleSteps();
        const currentStep = steps[state.stepIndex];
        if (!currentStep) return 'Start by selecting your preferences above to find cards that match your needs.';
        
        // Provide contextual tips based on step type and content
        switch (currentStep.id) {
            case 'cb2': // Cashback earning categories
                return 'For cash back, focus on 1-2 categories where you spend the most each month. Your flat-rate card will handle everything else at 2%.';
            
            case 'cb3': // Cashback protections
                return 'These protections can save hundreds of dollars when you need them. Phone protection alone often replaces paid insurance plans.';
            
            case 'tr3': // Travel earning categories  
                return 'Travel cards often earn 2-3x on dining and travel. Focus on categories you hit regularly—your travel card covers the rest at 1x.';
            
            case 'tr1b': // Travel brands (airlines/hotels)
                return 'Brand cards are best when you\'re loyal to that specific airline or hotel. If you mix it up, flexible points are usually better.';
            
            case 'tr5': // Travel protections
                return 'Trip protections can reimburse thousands in cancelled flight costs. Rental car coverage can replace expensive counter insurance.';
            
            case 'goal': // Initial goal selection
                return 'Cash back is simpler and gives you real money. Travel rewards can offer more value but require more planning.';
                
            default:
                // Generic helpful advice for other steps
                if (state.mode === 'cashback') {
                    return 'Most people succeed with cash back by keeping it simple: one flat-rate card plus one category card for their biggest expense.';
                } else if (state.mode === 'travel') {
                    return 'Travel rewards work best when you focus on a specific strategy: either flexible points OR loyalty to one airline/hotel.';
                } else {
                    return 'The best card strategy is one you\'ll actually use consistently. Start simple and add complexity only if it\'s worth it.';
                }
        }
    }

    function renderZeroState() {
        const grid = document.getElementById('cards-grid');
        currentCards = []; // Reset current cards state when showing zero state
        const nameMap = {
            type:{travel:'Travel',cashback:'Cash back'},
            perks:{'lounge-access':'Lounge Access','no-foreign-fees':'No Foreign Transaction Fees'},
            protections:{'trip-delay-cancellation':'Trip Protections','rental-car-insurance':'Rental Car Insurance','cell-phone-protection':'Cell Phone Protection','lost-delayed-baggage':'Lost/Delayed Baggage'},
            'airline-hotel':{'delta':'Delta','united':'United','american':'American','southwest':'Southwest','jetblue':'JetBlue','alaska':'Alaska','marriott':'Marriott','hilton':'Hilton','hyatt':'Hyatt','ihg':'IHG','wyndham':'Wyndham','choice':'Choice'},
            earning_any:{'flat-rate':'Flat Rate','dining':'Dining','groceries':'Groceries','gas':'Gas','transit':'Transit','travel':'Travel','hotels':'Hotels','flights':'Flights','drugstores':'Drugstores','online':'Online','streaming':'Streaming','telecom':'Telecom','entertainment':'Entertainment','amazon':'Amazon','gas|ev-charging':'Gas/EV Charging','rideshare|transit':'Rideshare/Transit','travel|hotels|airlines':'Travel','wholesale-clubs':'Wholesale Clubs'}
        };
        const last = state.lastApplied;
        const lastLabel = last && nameMap[last.key] ? (nameMap[last.key][last.value] || last.value) : 'the last filter';
        
        grid.classList.add('showing-intro');
        grid.innerHTML = `
            <div style="width: 100%; margin: 0; padding: 2.5rem 2rem; text-align: center; background: #fff; border-radius: 16px; border: 1px solid #e5e7eb; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);">
                <!-- Main message -->
                <h3 style="color: #1e293b; font-weight: 600; font-size: 1.25rem; margin-bottom: 0.75rem; line-height: 1.3;">
                    No cards match your exact criteria
                </h3>
                
                <!-- Explanation -->
                <p style="color: #64748b; font-size: 1rem; line-height: 1.6; margin-bottom: 1.5rem; max-width: 400px; margin-left: auto; margin-right: auto;">
                    Your combination of preferences is pretty specific! Try adjusting some of your choices to see more options.
                </p>
                
                <!-- Action buttons -->
                <div style="display: flex; flex-direction: column; gap: 0.75rem; align-items: center;">
                    ${last && last.key ? `
                    <button id="remove-last" style="
                        background: #059669; 
                        color: white; 
                        border: none; 
                        padding: 0.75rem 1.5rem; 
                        border-radius: 8px; 
                        font-weight: 600; 
                        cursor: pointer;
                        font-size: 0.95rem;
                        transition: background 0.2s ease;
                    " onmouseover="this.style.background='#047857'" onmouseout="this.style.background='#059669'">
                        Unselect ${lastLabel}
                    </button>
                    ` : ''}
                    
                    <button id="clear-current-step" style="
                        background: white; 
                        color: #059669; 
                        border: 1px solid #059669; 
                        padding: 0.75rem 1.5rem; 
                        border-radius: 8px; 
                        font-weight: 600; 
                        cursor: pointer;
                        font-size: 0.95rem;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                        Clear All Selections
                    </button>
                </div>
                
                <!-- Helpful tip -->
                <div style="background: #f8fafc; border-left: 3px solid #059669; padding: 1rem; margin-top: 1.5rem; border-radius: 0 8px 8px 0; text-align: left;">
                    <div style="color: #059669; font-weight: 600; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">
                        Tip
                    </div>
                    <div style="color: #475569; font-size: 0.9rem; line-height: 1.5;">
                        ${getContextualTip()}
                    </div>
                </div>
            </div>
        `;
        
        // Wire up the remove last filter button
        const removeBtn = document.getElementById('remove-last');
        if (removeBtn && last && last.key) {
            removeBtn.addEventListener('click', () => removeFilter(last.key, last.value));
        }
        
        // Wire up the clear current step button
        const clearBtn = document.getElementById('clear-current-step');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => clearCurrentStepSelections());
        }
        
        // Hide mobile scroll indicator when showing zero state
        const mobileIndicator = document.getElementById('mobile-scroll-indicator');
        if (mobileIndicator) {
            mobileIndicator.style.display = 'none';
        }

        // Hide desktop card count when showing zero state
        const desktopIndicator = document.getElementById('desktop-card-count');
        if (desktopIndicator) {
            desktopIndicator.style.display = 'none';
        }
    }

    function resetAllFilters() {
        console.log('Resetting all filters...');
        
        // Reset all filter states
        state.travelFilters = {};
        state.cashbackFilters = {};
        state.baseFilters = {};
        
        // Reset wizard state to beginning
        state.stepIndex = 0;
        state.mode = null;
        state.lastApplied = null;
        
        // Re-render the wizard and results
        renderStep();
        recomputeAndRender();
        
        // Hide the active filters line
        document.getElementById('active-filters-line').style.display = 'none';
        
        console.log('Filters reset complete. State:', state);
    }
    </script>
</body>
</html>

